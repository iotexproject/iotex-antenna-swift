// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/api/api.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2019 IoTeX
// This is an alpha (internal) release and is not suitable for production. This source code is provided 'as is' and no
// warranties are given as to title or non-infringement, merchantability or fitness for purpose and, to the extent
// permitted by law, all liability for your use of the code is disclaimed. This source code is governed by Apache
// License 2.0 that can be found in the LICENSE file.

/// To compile the proto, run:
///      protoc -I. -I ./../types --go_out=plugins=grpc:$GOPATH/src *.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Iotexapi_GetAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountMeta: Iotextypes_AccountMeta {
    get {return _storage._accountMeta ?? Iotextypes_AccountMeta()}
    set {_uniqueStorage()._accountMeta = newValue}
  }
  /// Returns true if `accountMeta` has been explicitly set.
  var hasAccountMeta: Bool {return _storage._accountMeta != nil}
  /// Clears the value of `accountMeta`. Subsequent reads from it will return its default value.
  mutating func clearAccountMeta() {_uniqueStorage()._accountMeta = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_GetActionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lookup: OneOf_Lookup? {
    get {return _storage._lookup}
    set {_uniqueStorage()._lookup = newValue}
  }

  var byIndex: Iotexapi_GetActionsByIndexRequest {
    get {
      if case .byIndex(let v)? = _storage._lookup {return v}
      return Iotexapi_GetActionsByIndexRequest()
    }
    set {_uniqueStorage()._lookup = .byIndex(newValue)}
  }

  var byHash: Iotexapi_GetActionByHashRequest {
    get {
      if case .byHash(let v)? = _storage._lookup {return v}
      return Iotexapi_GetActionByHashRequest()
    }
    set {_uniqueStorage()._lookup = .byHash(newValue)}
  }

  var byAddr: Iotexapi_GetActionsByAddressRequest {
    get {
      if case .byAddr(let v)? = _storage._lookup {return v}
      return Iotexapi_GetActionsByAddressRequest()
    }
    set {_uniqueStorage()._lookup = .byAddr(newValue)}
  }

  var unconfirmedByAddr: Iotexapi_GetUnconfirmedActionsByAddressRequest {
    get {
      if case .unconfirmedByAddr(let v)? = _storage._lookup {return v}
      return Iotexapi_GetUnconfirmedActionsByAddressRequest()
    }
    set {_uniqueStorage()._lookup = .unconfirmedByAddr(newValue)}
  }

  var byBlk: Iotexapi_GetActionsByBlockRequest {
    get {
      if case .byBlk(let v)? = _storage._lookup {return v}
      return Iotexapi_GetActionsByBlockRequest()
    }
    set {_uniqueStorage()._lookup = .byBlk(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Lookup: Equatable {
    case byIndex(Iotexapi_GetActionsByIndexRequest)
    case byHash(Iotexapi_GetActionByHashRequest)
    case byAddr(Iotexapi_GetActionsByAddressRequest)
    case unconfirmedByAddr(Iotexapi_GetUnconfirmedActionsByAddressRequest)
    case byBlk(Iotexapi_GetActionsByBlockRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Iotexapi_GetActionsRequest.OneOf_Lookup, rhs: Iotexapi_GetActionsRequest.OneOf_Lookup) -> Bool {
      switch (lhs, rhs) {
      case (.byIndex(let l), .byIndex(let r)): return l == r
      case (.byHash(let l), .byHash(let r)): return l == r
      case (.byAddr(let l), .byAddr(let r)): return l == r
      case (.unconfirmedByAddr(let l), .unconfirmedByAddr(let r)): return l == r
      case (.byBlk(let l), .byBlk(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_GetActionsByIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: UInt64 = 0

  var count: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetActionByHashRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionHash: String = String()

  var checkPending: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetActionsByAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var start: UInt64 = 0

  var count: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetUnconfirmedActionsByAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var start: UInt64 = 0

  var count: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetActionsByBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blkHash: String = String()

  var start: UInt64 = 0

  var count: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_ActionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: Iotextypes_Action {
    get {return _storage._action ?? Iotextypes_Action()}
    set {_uniqueStorage()._action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return _storage._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {_uniqueStorage()._action = nil}

  var actHash: String {
    get {return _storage._actHash}
    set {_uniqueStorage()._actHash = newValue}
  }

  var blkHash: String {
    get {return _storage._blkHash}
    set {_uniqueStorage()._blkHash = newValue}
  }

  var blkHeight: UInt64 {
    get {return _storage._blkHeight}
    set {_uniqueStorage()._blkHeight = newValue}
  }

  var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  var gasFee: String {
    get {return _storage._gasFee}
    set {_uniqueStorage()._gasFee = newValue}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_ReceiptInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var receipt: Iotextypes_Receipt {
    get {return _storage._receipt ?? Iotextypes_Receipt()}
    set {_uniqueStorage()._receipt = newValue}
  }
  /// Returns true if `receipt` has been explicitly set.
  var hasReceipt: Bool {return _storage._receipt != nil}
  /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
  mutating func clearReceipt() {_uniqueStorage()._receipt = nil}

  var blkHash: String {
    get {return _storage._blkHash}
    set {_uniqueStorage()._blkHash = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_BlockProducerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var votes: String = String()

  var active: Bool = false

  var production: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_BlockInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Iotextypes_Block {
    get {return _storage._block ?? Iotextypes_Block()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {_uniqueStorage()._block = nil}

  var receipts: [Iotextypes_Receipt] {
    get {return _storage._receipts}
    set {_uniqueStorage()._receipts = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_GetActionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var total: UInt64 = 0

  var actionInfo: [Iotexapi_ActionInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetBlockMetasRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lookup: OneOf_Lookup? {
    get {return _storage._lookup}
    set {_uniqueStorage()._lookup = newValue}
  }

  var byIndex: Iotexapi_GetBlockMetasByIndexRequest {
    get {
      if case .byIndex(let v)? = _storage._lookup {return v}
      return Iotexapi_GetBlockMetasByIndexRequest()
    }
    set {_uniqueStorage()._lookup = .byIndex(newValue)}
  }

  var byHash: Iotexapi_GetBlockMetaByHashRequest {
    get {
      if case .byHash(let v)? = _storage._lookup {return v}
      return Iotexapi_GetBlockMetaByHashRequest()
    }
    set {_uniqueStorage()._lookup = .byHash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Lookup: Equatable {
    case byIndex(Iotexapi_GetBlockMetasByIndexRequest)
    case byHash(Iotexapi_GetBlockMetaByHashRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Iotexapi_GetBlockMetasRequest.OneOf_Lookup, rhs: Iotexapi_GetBlockMetasRequest.OneOf_Lookup) -> Bool {
      switch (lhs, rhs) {
      case (.byIndex(let l), .byIndex(let r)): return l == r
      case (.byHash(let l), .byHash(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_GetBlockMetasByIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: UInt64 = 0

  var count: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetBlockMetaByHashRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blkHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetBlockMetasResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var total: UInt64 = 0

  var blkMetas: [Iotextypes_BlockMeta] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetChainMetaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetChainMetaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainMeta: Iotextypes_ChainMeta {
    get {return _storage._chainMeta ?? Iotextypes_ChainMeta()}
    set {_uniqueStorage()._chainMeta = newValue}
  }
  /// Returns true if `chainMeta` has been explicitly set.
  var hasChainMeta: Bool {return _storage._chainMeta != nil}
  /// Clears the value of `chainMeta`. Subsequent reads from it will return its default value.
  mutating func clearChainMeta() {_uniqueStorage()._chainMeta = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_GetServerMetaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetServerMetaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverMeta: Iotextypes_ServerMeta {
    get {return _storage._serverMeta ?? Iotextypes_ServerMeta()}
    set {_uniqueStorage()._serverMeta = newValue}
  }
  /// Returns true if `serverMeta` has been explicitly set.
  var hasServerMeta: Bool {return _storage._serverMeta != nil}
  /// Clears the value of `serverMeta`. Subsequent reads from it will return its default value.
  mutating func clearServerMeta() {_uniqueStorage()._serverMeta = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_SendActionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: Iotextypes_Action {
    get {return _storage._action ?? Iotextypes_Action()}
    set {_uniqueStorage()._action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return _storage._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {_uniqueStorage()._action = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_SendSignedActionBytesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signedActionBytes: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_SendActionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetReceiptByActionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetReceiptByActionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var receiptInfo: Iotexapi_ReceiptInfo {
    get {return _storage._receiptInfo ?? Iotexapi_ReceiptInfo()}
    set {_uniqueStorage()._receiptInfo = newValue}
  }
  /// Returns true if `receiptInfo` has been explicitly set.
  var hasReceiptInfo: Bool {return _storage._receiptInfo != nil}
  /// Clears the value of `receiptInfo`. Subsequent reads from it will return its default value.
  mutating func clearReceiptInfo() {_uniqueStorage()._receiptInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_ReadContractRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var execution: Iotextypes_Execution {
    get {return _storage._execution ?? Iotextypes_Execution()}
    set {_uniqueStorage()._execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  var hasExecution: Bool {return _storage._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  mutating func clearExecution() {_uniqueStorage()._execution = nil}

  var callerAddress: String {
    get {return _storage._callerAddress}
    set {_uniqueStorage()._callerAddress = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_ReadContractResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: String {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var receipt: Iotextypes_Receipt {
    get {return _storage._receipt ?? Iotextypes_Receipt()}
    set {_uniqueStorage()._receipt = newValue}
  }
  /// Returns true if `receipt` has been explicitly set.
  var hasReceipt: Bool {return _storage._receipt != nil}
  /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
  mutating func clearReceipt() {_uniqueStorage()._receipt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_SuggestGasPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_SuggestGasPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gasPrice: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// To be deprecated
struct Iotexapi_EstimateGasForActionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: Iotextypes_Action {
    get {return _storage._action ?? Iotextypes_Action()}
    set {_uniqueStorage()._action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return _storage._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {_uniqueStorage()._action = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_EstimateActionGasConsumptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  var transfer: Iotextypes_Transfer {
    get {
      if case .transfer(let v)? = _storage._action {return v}
      return Iotextypes_Transfer()
    }
    set {_uniqueStorage()._action = .transfer(newValue)}
  }

  var execution: Iotextypes_Execution {
    get {
      if case .execution(let v)? = _storage._action {return v}
      return Iotextypes_Execution()
    }
    set {_uniqueStorage()._action = .execution(newValue)}
  }

  var callerAddress: String {
    get {return _storage._callerAddress}
    set {_uniqueStorage()._callerAddress = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Action: Equatable {
    case transfer(Iotextypes_Transfer)
    case execution(Iotextypes_Execution)

  #if !swift(>=4.1)
    static func ==(lhs: Iotexapi_EstimateActionGasConsumptionRequest.OneOf_Action, rhs: Iotexapi_EstimateActionGasConsumptionRequest.OneOf_Action) -> Bool {
      switch (lhs, rhs) {
      case (.transfer(let l), .transfer(let r)): return l == r
      case (.execution(let l), .execution(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_EstimateActionGasConsumptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gas: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_EstimateGasForActionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gas: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_ReadStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var protocolID: Data = SwiftProtobuf.Internal.emptyData

  var methodName: Data = SwiftProtobuf.Internal.emptyData

  var arguments: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_ReadStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetEpochMetaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetEpochMetaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochData: Iotextypes_EpochData {
    get {return _storage._epochData ?? Iotextypes_EpochData()}
    set {_uniqueStorage()._epochData = newValue}
  }
  /// Returns true if `epochData` has been explicitly set.
  var hasEpochData: Bool {return _storage._epochData != nil}
  /// Clears the value of `epochData`. Subsequent reads from it will return its default value.
  mutating func clearEpochData() {_uniqueStorage()._epochData = nil}

  var totalBlocks: UInt64 {
    get {return _storage._totalBlocks}
    set {_uniqueStorage()._totalBlocks = newValue}
  }

  var blockProducersInfo: [Iotexapi_BlockProducerInfo] {
    get {return _storage._blockProducersInfo}
    set {_uniqueStorage()._blockProducersInfo = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_GetRawBlocksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startHeight: UInt64 = 0

  var count: UInt64 = 0

  var withReceipts: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetRawBlocksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blocks: [Iotexapi_BlockInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetLogsByBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetLogsByRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fromBlock: UInt64 = 0

  var count: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_Topics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topic: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_LogsFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: [String] = []

  var topics: [Iotexapi_Topics] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_GetLogsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filter: Iotexapi_LogsFilter {
    get {return _storage._filter ?? Iotexapi_LogsFilter()}
    set {_uniqueStorage()._filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return _storage._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {_uniqueStorage()._filter = nil}

  var lookup: OneOf_Lookup? {
    get {return _storage._lookup}
    set {_uniqueStorage()._lookup = newValue}
  }

  var byBlock: Iotexapi_GetLogsByBlock {
    get {
      if case .byBlock(let v)? = _storage._lookup {return v}
      return Iotexapi_GetLogsByBlock()
    }
    set {_uniqueStorage()._lookup = .byBlock(newValue)}
  }

  var byRange: Iotexapi_GetLogsByRange {
    get {
      if case .byRange(let v)? = _storage._lookup {return v}
      return Iotexapi_GetLogsByRange()
    }
    set {_uniqueStorage()._lookup = .byRange(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Lookup: Equatable {
    case byBlock(Iotexapi_GetLogsByBlock)
    case byRange(Iotexapi_GetLogsByRange)

  #if !swift(>=4.1)
    static func ==(lhs: Iotexapi_GetLogsRequest.OneOf_Lookup, rhs: Iotexapi_GetLogsRequest.OneOf_Lookup) -> Bool {
      switch (lhs, rhs) {
      case (.byBlock(let l), .byBlock(let r)): return l == r
      case (.byRange(let l), .byRange(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_GetLogsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logs: [Iotextypes_Log] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// below are streaming APIs
struct Iotexapi_StreamBlocksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iotexapi_StreamBlocksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Iotexapi_BlockInfo {
    get {return _storage._block ?? Iotexapi_BlockInfo()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {_uniqueStorage()._block = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_StreamLogsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filter: Iotexapi_LogsFilter {
    get {return _storage._filter ?? Iotexapi_LogsFilter()}
    set {_uniqueStorage()._filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return _storage._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {_uniqueStorage()._filter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotexapi_StreamLogsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var log: Iotextypes_Log {
    get {return _storage._log ?? Iotextypes_Log()}
    set {_uniqueStorage()._log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  var hasLog: Bool {return _storage._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  mutating func clearLog() {_uniqueStorage()._log = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iotexapi"

extension Iotexapi_GetAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetAccountRequest, rhs: Iotexapi_GetAccountRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountMeta"),
  ]

  fileprivate class _StorageClass {
    var _accountMeta: Iotextypes_AccountMeta? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountMeta = source._accountMeta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accountMeta)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountMeta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetAccountResponse, rhs: Iotexapi_GetAccountResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountMeta != rhs_storage._accountMeta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetActionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetActionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "byIndex"),
    2: .same(proto: "byHash"),
    3: .same(proto: "byAddr"),
    4: .same(proto: "unconfirmedByAddr"),
    5: .same(proto: "byBlk"),
  ]

  fileprivate class _StorageClass {
    var _lookup: Iotexapi_GetActionsRequest.OneOf_Lookup?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lookup = source._lookup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Iotexapi_GetActionsByIndexRequest?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .byIndex(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .byIndex(v)}
        case 2:
          var v: Iotexapi_GetActionByHashRequest?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .byHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .byHash(v)}
        case 3:
          var v: Iotexapi_GetActionsByAddressRequest?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .byAddr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .byAddr(v)}
        case 4:
          var v: Iotexapi_GetUnconfirmedActionsByAddressRequest?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .unconfirmedByAddr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .unconfirmedByAddr(v)}
        case 5:
          var v: Iotexapi_GetActionsByBlockRequest?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .byBlk(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .byBlk(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._lookup {
      case .byIndex(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .byHash(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .byAddr(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .unconfirmedByAddr(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .byBlk(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetActionsRequest, rhs: Iotexapi_GetActionsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lookup != rhs_storage._lookup {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetActionsByIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetActionsByIndexRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.start)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.count)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetActionsByIndexRequest, rhs: Iotexapi_GetActionsByIndexRequest) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetActionByHashRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetActionByHashRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionHash"),
    2: .same(proto: "checkPending"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.actionHash)
      case 2: try decoder.decodeSingularBoolField(value: &self.checkPending)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionHash.isEmpty {
      try visitor.visitSingularStringField(value: self.actionHash, fieldNumber: 1)
    }
    if self.checkPending != false {
      try visitor.visitSingularBoolField(value: self.checkPending, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetActionByHashRequest, rhs: Iotexapi_GetActionByHashRequest) -> Bool {
    if lhs.actionHash != rhs.actionHash {return false}
    if lhs.checkPending != rhs.checkPending {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetActionsByAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetActionsByAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "start"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.start)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.count)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetActionsByAddressRequest, rhs: Iotexapi_GetActionsByAddressRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.start != rhs.start {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetUnconfirmedActionsByAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUnconfirmedActionsByAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "start"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.start)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.count)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetUnconfirmedActionsByAddressRequest, rhs: Iotexapi_GetUnconfirmedActionsByAddressRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.start != rhs.start {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetActionsByBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetActionsByBlockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blkHash"),
    2: .same(proto: "start"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.blkHash)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.start)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.count)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blkHash.isEmpty {
      try visitor.visitSingularStringField(value: self.blkHash, fieldNumber: 1)
    }
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetActionsByBlockRequest, rhs: Iotexapi_GetActionsByBlockRequest) -> Bool {
    if lhs.blkHash != rhs.blkHash {return false}
    if lhs.start != rhs.start {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_ActionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "actHash"),
    3: .same(proto: "blkHash"),
    5: .same(proto: "blkHeight"),
    6: .same(proto: "sender"),
    7: .same(proto: "gasFee"),
    4: .same(proto: "timestamp"),
  ]

  fileprivate class _StorageClass {
    var _action: Iotextypes_Action? = nil
    var _actHash: String = String()
    var _blkHash: String = String()
    var _blkHeight: UInt64 = 0
    var _sender: String = String()
    var _gasFee: String = String()
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _actHash = source._actHash
      _blkHash = source._blkHash
      _blkHeight = source._blkHeight
      _sender = source._sender
      _gasFee = source._gasFee
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._action)
        case 2: try decoder.decodeSingularStringField(value: &_storage._actHash)
        case 3: try decoder.decodeSingularStringField(value: &_storage._blkHash)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._blkHeight)
        case 6: try decoder.decodeSingularStringField(value: &_storage._sender)
        case 7: try decoder.decodeSingularStringField(value: &_storage._gasFee)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._actHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actHash, fieldNumber: 2)
      }
      if !_storage._blkHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blkHash, fieldNumber: 3)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._blkHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._blkHeight, fieldNumber: 5)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 6)
      }
      if !_storage._gasFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gasFee, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_ActionInfo, rhs: Iotexapi_ActionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._actHash != rhs_storage._actHash {return false}
        if _storage._blkHash != rhs_storage._blkHash {return false}
        if _storage._blkHeight != rhs_storage._blkHeight {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._gasFee != rhs_storage._gasFee {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_ReceiptInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiptInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receipt"),
    2: .same(proto: "blkHash"),
  ]

  fileprivate class _StorageClass {
    var _receipt: Iotextypes_Receipt? = nil
    var _blkHash: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _receipt = source._receipt
      _blkHash = source._blkHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._receipt)
        case 2: try decoder.decodeSingularStringField(value: &_storage._blkHash)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._receipt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._blkHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blkHash, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_ReceiptInfo, rhs: Iotexapi_ReceiptInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._receipt != rhs_storage._receipt {return false}
        if _storage._blkHash != rhs_storage._blkHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_BlockProducerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockProducerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "votes"),
    3: .same(proto: "active"),
    4: .same(proto: "production"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularStringField(value: &self.votes)
      case 3: try decoder.decodeSingularBoolField(value: &self.active)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.production)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitSingularStringField(value: self.votes, fieldNumber: 2)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 3)
    }
    if self.production != 0 {
      try visitor.visitSingularUInt64Field(value: self.production, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_BlockProducerInfo, rhs: Iotexapi_BlockProducerInfo) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.active != rhs.active {return false}
    if lhs.production != rhs.production {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_BlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "receipts"),
  ]

  fileprivate class _StorageClass {
    var _block: Iotextypes_Block? = nil
    var _receipts: [Iotextypes_Receipt] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _block = source._block
      _receipts = source._receipts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._block)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._receipts)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._receipts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._receipts, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_BlockInfo, rhs: Iotexapi_BlockInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._block != rhs_storage._block {return false}
        if _storage._receipts != rhs_storage._receipts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetActionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetActionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "total"),
    1: .same(proto: "actionInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.actionInfo)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.total)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionInfo, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularUInt64Field(value: self.total, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetActionsResponse, rhs: Iotexapi_GetActionsResponse) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.actionInfo != rhs.actionInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetBlockMetasRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockMetasRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "byIndex"),
    2: .same(proto: "byHash"),
  ]

  fileprivate class _StorageClass {
    var _lookup: Iotexapi_GetBlockMetasRequest.OneOf_Lookup?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lookup = source._lookup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Iotexapi_GetBlockMetasByIndexRequest?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .byIndex(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .byIndex(v)}
        case 2:
          var v: Iotexapi_GetBlockMetaByHashRequest?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .byHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .byHash(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._lookup {
      case .byIndex(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .byHash(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetBlockMetasRequest, rhs: Iotexapi_GetBlockMetasRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lookup != rhs_storage._lookup {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetBlockMetasByIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockMetasByIndexRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.start)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.count)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetBlockMetasByIndexRequest, rhs: Iotexapi_GetBlockMetasByIndexRequest) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetBlockMetaByHashRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockMetaByHashRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blkHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.blkHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blkHash.isEmpty {
      try visitor.visitSingularStringField(value: self.blkHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetBlockMetaByHashRequest, rhs: Iotexapi_GetBlockMetaByHashRequest) -> Bool {
    if lhs.blkHash != rhs.blkHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetBlockMetasResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockMetasResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "total"),
    1: .same(proto: "blkMetas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.blkMetas)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.total)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blkMetas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blkMetas, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularUInt64Field(value: self.total, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetBlockMetasResponse, rhs: Iotexapi_GetBlockMetasResponse) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.blkMetas != rhs.blkMetas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetChainMetaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChainMetaRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetChainMetaRequest, rhs: Iotexapi_GetChainMetaRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetChainMetaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChainMetaResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainMeta"),
  ]

  fileprivate class _StorageClass {
    var _chainMeta: Iotextypes_ChainMeta? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chainMeta = source._chainMeta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._chainMeta)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._chainMeta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetChainMetaResponse, rhs: Iotexapi_GetChainMetaResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chainMeta != rhs_storage._chainMeta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetServerMetaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetServerMetaRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetServerMetaRequest, rhs: Iotexapi_GetServerMetaRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetServerMetaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetServerMetaResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverMeta"),
  ]

  fileprivate class _StorageClass {
    var _serverMeta: Iotextypes_ServerMeta? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _serverMeta = source._serverMeta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._serverMeta)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._serverMeta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetServerMetaResponse, rhs: Iotexapi_GetServerMetaResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._serverMeta != rhs_storage._serverMeta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_SendActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendActionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
  ]

  fileprivate class _StorageClass {
    var _action: Iotextypes_Action? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._action)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_SendActionRequest, rhs: Iotexapi_SendActionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_SendSignedActionBytesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendSignedActionBytesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signedActionBytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.signedActionBytes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedActionBytes.isEmpty {
      try visitor.visitSingularStringField(value: self.signedActionBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_SendSignedActionBytesRequest, rhs: Iotexapi_SendSignedActionBytesRequest) -> Bool {
    if lhs.signedActionBytes != rhs.signedActionBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_SendActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.actionHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionHash.isEmpty {
      try visitor.visitSingularStringField(value: self.actionHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_SendActionResponse, rhs: Iotexapi_SendActionResponse) -> Bool {
    if lhs.actionHash != rhs.actionHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetReceiptByActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReceiptByActionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.actionHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionHash.isEmpty {
      try visitor.visitSingularStringField(value: self.actionHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetReceiptByActionRequest, rhs: Iotexapi_GetReceiptByActionRequest) -> Bool {
    if lhs.actionHash != rhs.actionHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetReceiptByActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReceiptByActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiptInfo"),
  ]

  fileprivate class _StorageClass {
    var _receiptInfo: Iotexapi_ReceiptInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _receiptInfo = source._receiptInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._receiptInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._receiptInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetReceiptByActionResponse, rhs: Iotexapi_GetReceiptByActionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._receiptInfo != rhs_storage._receiptInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_ReadContractRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadContractRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "execution"),
    2: .same(proto: "callerAddress"),
  ]

  fileprivate class _StorageClass {
    var _execution: Iotextypes_Execution? = nil
    var _callerAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _execution = source._execution
      _callerAddress = source._callerAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._execution)
        case 2: try decoder.decodeSingularStringField(value: &_storage._callerAddress)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._execution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._callerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callerAddress, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_ReadContractRequest, rhs: Iotexapi_ReadContractRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._execution != rhs_storage._execution {return false}
        if _storage._callerAddress != rhs_storage._callerAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_ReadContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "receipt"),
  ]

  fileprivate class _StorageClass {
    var _data: String = String()
    var _receipt: Iotextypes_Receipt? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
      _receipt = source._receipt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._data)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._receipt)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._data.isEmpty {
        try visitor.visitSingularStringField(value: _storage._data, fieldNumber: 1)
      }
      if let v = _storage._receipt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_ReadContractResponse, rhs: Iotexapi_ReadContractResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        if _storage._receipt != rhs_storage._receipt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_SuggestGasPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SuggestGasPriceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_SuggestGasPriceRequest, rhs: Iotexapi_SuggestGasPriceRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_SuggestGasPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SuggestGasPriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gasPrice"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.gasPrice)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gasPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasPrice, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_SuggestGasPriceResponse, rhs: Iotexapi_SuggestGasPriceResponse) -> Bool {
    if lhs.gasPrice != rhs.gasPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_EstimateGasForActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateGasForActionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
  ]

  fileprivate class _StorageClass {
    var _action: Iotextypes_Action? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._action)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_EstimateGasForActionRequest, rhs: Iotexapi_EstimateGasForActionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_EstimateActionGasConsumptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateActionGasConsumptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transfer"),
    2: .same(proto: "execution"),
    100: .same(proto: "callerAddress"),
  ]

  fileprivate class _StorageClass {
    var _action: Iotexapi_EstimateActionGasConsumptionRequest.OneOf_Action?
    var _callerAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _callerAddress = source._callerAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Iotextypes_Transfer?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .transfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .transfer(v)}
        case 2:
          var v: Iotextypes_Execution?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .execution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .execution(v)}
        case 100: try decoder.decodeSingularStringField(value: &_storage._callerAddress)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._action {
      case .transfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .execution(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
      if !_storage._callerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callerAddress, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_EstimateActionGasConsumptionRequest, rhs: Iotexapi_EstimateActionGasConsumptionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._callerAddress != rhs_storage._callerAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_EstimateActionGasConsumptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateActionGasConsumptionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.gas)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_EstimateActionGasConsumptionResponse, rhs: Iotexapi_EstimateActionGasConsumptionResponse) -> Bool {
    if lhs.gas != rhs.gas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_EstimateGasForActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateGasForActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.gas)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_EstimateGasForActionResponse, rhs: Iotexapi_EstimateGasForActionResponse) -> Bool {
    if lhs.gas != rhs.gas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_ReadStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadStateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protocolID"),
    2: .same(proto: "methodName"),
    3: .same(proto: "arguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.protocolID)
      case 2: try decoder.decodeSingularBytesField(value: &self.methodName)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.arguments)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.protocolID.isEmpty {
      try visitor.visitSingularBytesField(value: self.protocolID, fieldNumber: 1)
    }
    if !self.methodName.isEmpty {
      try visitor.visitSingularBytesField(value: self.methodName, fieldNumber: 2)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.arguments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_ReadStateRequest, rhs: Iotexapi_ReadStateRequest) -> Bool {
    if lhs.protocolID != rhs.protocolID {return false}
    if lhs.methodName != rhs.methodName {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_ReadStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_ReadStateResponse, rhs: Iotexapi_ReadStateResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetEpochMetaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetEpochMetaRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epochNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.epochNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetEpochMetaRequest, rhs: Iotexapi_GetEpochMetaRequest) -> Bool {
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetEpochMetaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetEpochMetaResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epochData"),
    2: .same(proto: "totalBlocks"),
    3: .same(proto: "blockProducersInfo"),
  ]

  fileprivate class _StorageClass {
    var _epochData: Iotextypes_EpochData? = nil
    var _totalBlocks: UInt64 = 0
    var _blockProducersInfo: [Iotexapi_BlockProducerInfo] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _epochData = source._epochData
      _totalBlocks = source._totalBlocks
      _blockProducersInfo = source._blockProducersInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._epochData)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._totalBlocks)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._blockProducersInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._epochData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._totalBlocks != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalBlocks, fieldNumber: 2)
      }
      if !_storage._blockProducersInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blockProducersInfo, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetEpochMetaResponse, rhs: Iotexapi_GetEpochMetaResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._epochData != rhs_storage._epochData {return false}
        if _storage._totalBlocks != rhs_storage._totalBlocks {return false}
        if _storage._blockProducersInfo != rhs_storage._blockProducersInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetRawBlocksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawBlocksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startHeight"),
    2: .same(proto: "count"),
    3: .same(proto: "withReceipts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.startHeight)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.count)
      case 3: try decoder.decodeSingularBoolField(value: &self.withReceipts)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.startHeight, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 2)
    }
    if self.withReceipts != false {
      try visitor.visitSingularBoolField(value: self.withReceipts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetRawBlocksRequest, rhs: Iotexapi_GetRawBlocksRequest) -> Bool {
    if lhs.startHeight != rhs.startHeight {return false}
    if lhs.count != rhs.count {return false}
    if lhs.withReceipts != rhs.withReceipts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetRawBlocksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawBlocksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.blocks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetRawBlocksResponse, rhs: Iotexapi_GetRawBlocksResponse) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetLogsByBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLogsByBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.blockHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetLogsByBlock, rhs: Iotexapi_GetLogsByBlock) -> Bool {
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetLogsByRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLogsByRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromBlock"),
    2: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.fromBlock)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.count)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fromBlock != 0 {
      try visitor.visitSingularUInt64Field(value: self.fromBlock, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetLogsByRange, rhs: Iotexapi_GetLogsByRange) -> Bool {
    if lhs.fromBlock != rhs.fromBlock {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_Topics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Topics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.topic)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_Topics, rhs: Iotexapi_Topics) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_LogsFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogsFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "topics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.topics)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitRepeatedStringField(value: self.address, fieldNumber: 1)
    }
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_LogsFilter, rhs: Iotexapi_LogsFilter) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetLogsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLogsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    2: .same(proto: "byBlock"),
    3: .same(proto: "byRange"),
  ]

  fileprivate class _StorageClass {
    var _filter: Iotexapi_LogsFilter? = nil
    var _lookup: Iotexapi_GetLogsRequest.OneOf_Lookup?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _filter = source._filter
      _lookup = source._lookup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._filter)
        case 2:
          var v: Iotexapi_GetLogsByBlock?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .byBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .byBlock(v)}
        case 3:
          var v: Iotexapi_GetLogsByRange?
          if let current = _storage._lookup {
            try decoder.handleConflictingOneOf()
            if case .byRange(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lookup = .byRange(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._lookup {
      case .byBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .byRange(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetLogsRequest, rhs: Iotexapi_GetLogsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._lookup != rhs_storage._lookup {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_GetLogsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLogsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.logs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_GetLogsResponse, rhs: Iotexapi_GetLogsResponse) -> Bool {
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_StreamBlocksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamBlocksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_StreamBlocksRequest, rhs: Iotexapi_StreamBlocksRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_StreamBlocksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamBlocksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
  ]

  fileprivate class _StorageClass {
    var _block: Iotexapi_BlockInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _block = source._block
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._block)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_StreamBlocksResponse, rhs: Iotexapi_StreamBlocksResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._block != rhs_storage._block {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_StreamLogsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamLogsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
  ]

  fileprivate class _StorageClass {
    var _filter: Iotexapi_LogsFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _filter = source._filter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._filter)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_StreamLogsRequest, rhs: Iotexapi_StreamLogsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._filter != rhs_storage._filter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotexapi_StreamLogsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamLogsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "log"),
  ]

  fileprivate class _StorageClass {
    var _log: Iotextypes_Log? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _log = source._log
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._log)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._log {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotexapi_StreamLogsResponse, rhs: Iotexapi_StreamLogsResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._log != rhs_storage._log {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
