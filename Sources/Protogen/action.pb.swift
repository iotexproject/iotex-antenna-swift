// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/types/action.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018 IoTeX
// This is an alpha (internal) release and is not suitable for production. This source code is provided 'as is' and no
// warranties are given as to title or non-infringement, merchantability or fitness for purpose and, to the extent
// permitted by law, all liability for your use of the code is disclaimed. This source code is governed by Apache
// License 2.0 that can be found in the LICENSE file.

/// To compile the proto, run:
///      protoc --go_out=plugins=grpc:$GOPATH/src *.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Iotextypes_Encoding: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case iotexProtobuf // = 0
  case ethereumRlp // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .iotexProtobuf
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .iotexProtobuf
    case 1: self = .ethereumRlp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .iotexProtobuf: return 0
    case .ethereumRlp: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Iotextypes_Encoding: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Iotextypes_Encoding] = [
    .iotexProtobuf,
    .ethereumRlp,
  ]
}

#endif  // swift(>=4.2)

public enum Iotextypes_RewardType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case blockReward // = 0
  case epochReward // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .blockReward
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .blockReward
    case 1: self = .epochReward
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .blockReward: return 0
    case .epochReward: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Iotextypes_RewardType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Iotextypes_RewardType] = [
    .blockReward,
    .epochReward,
  ]
}

#endif  // swift(>=4.2)

public struct Iotextypes_Transfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// used by state-based model
  public var amount: String = String()

  public var recipient: String = String()

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Candidates and list of candidates
public struct Iotextypes_Candidate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var votes: Data = SwiftProtobuf.Internal.emptyData

  public var pubKey: Data = SwiftProtobuf.Internal.emptyData

  public var rewardAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_CandidateList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var candidates: [Iotextypes_Candidate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PutPollResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var candidates: Iotextypes_CandidateList {
    get {return _storage._candidates ?? Iotextypes_CandidateList()}
    set {_uniqueStorage()._candidates = newValue}
  }
  /// Returns true if `candidates` has been explicitly set.
  public var hasCandidates: Bool {return _storage._candidates != nil}
  /// Clears the value of `candidates`. Subsequent reads from it will return its default value.
  public mutating func clearCandidates() {_uniqueStorage()._candidates = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Iotextypes_Execution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: String = String()

  public var contract: String = String()

  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// create stake
public struct Iotextypes_StakeCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var candidateName: String = String()

  public var stakedAmount: String = String()

  public var stakedDuration: UInt32 = 0

  public var autoStake: Bool = false

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// unstake or withdraw
public struct Iotextypes_StakeReclaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bucketIndex: UInt64 = 0

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// add the amount of bucket 
public struct Iotextypes_StakeAddDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bucketIndex: UInt64 = 0

  public var amount: String = String()

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// restake the duration and autoStake flag of bucket 
public struct Iotextypes_StakeRestake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bucketIndex: UInt64 = 0

  public var stakedDuration: UInt32 = 0

  public var autoStake: Bool = false

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// move the bucket to vote for another candidate or transfer the ownership of bucket to another voters
public struct Iotextypes_StakeChangeCandidate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bucketIndex: UInt64 = 0

  public var candidateName: String = String()

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_StakeTransferOwnership {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bucketIndex: UInt64 = 0

  public var voterAddress: String = String()

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_CandidateBasicInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var operatorAddress: String = String()

  public var rewardAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_CandidateRegister {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var candidate: Iotextypes_CandidateBasicInfo {
    get {return _storage._candidate ?? Iotextypes_CandidateBasicInfo()}
    set {_uniqueStorage()._candidate = newValue}
  }
  /// Returns true if `candidate` has been explicitly set.
  public var hasCandidate: Bool {return _storage._candidate != nil}
  /// Clears the value of `candidate`. Subsequent reads from it will return its default value.
  public mutating func clearCandidate() {_uniqueStorage()._candidate = nil}

  public var stakedAmount: String {
    get {return _storage._stakedAmount}
    set {_uniqueStorage()._stakedAmount = newValue}
  }

  public var stakedDuration: UInt32 {
    get {return _storage._stakedDuration}
    set {_uniqueStorage()._stakedDuration = newValue}
  }

  public var autoStake: Bool {
    get {return _storage._autoStake}
    set {_uniqueStorage()._autoStake = newValue}
  }

  /// if ownerAddress is absent, owner of candidate is the sender
  public var ownerAddress: String {
    get {return _storage._ownerAddress}
    set {_uniqueStorage()._ownerAddress = newValue}
  }

  public var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Iotextypes_StartSubChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: chainID chould be assigned by system and returned via a receipt
  public var chainID: UInt32 = 0

  public var securityDeposit: String = String()

  public var operationDeposit: String = String()

  public var startHeight: UInt64 = 0

  public var parentHeightOffset: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_StopSubChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainID: UInt32 = 0

  public var stopHeight: UInt64 = 0

  public var subChainAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_MerkleRoot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PutBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subChainAddress: String = String()

  public var height: UInt64 = 0

  public var roots: [Iotextypes_MerkleRoot] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_CreateDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainID: UInt32 = 0

  public var amount: String = String()

  public var recipient: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_SettleDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: String = String()

  public var recipient: String = String()

  public var index: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// plum main chain APIs
public struct Iotextypes_CreatePlumChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_TerminatePlumChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subChainAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PlumPutBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subChainAddress: String = String()

  public var height: UInt64 = 0

  public var roots: Dictionary<String,Data> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PlumCreateDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subChainAddress: String = String()

  public var amount: String = String()

  public var recipient: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PlumStartExit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subChainAddress: String = String()

  public var previousTransfer: Data = SwiftProtobuf.Internal.emptyData

  public var previousTransferBlockProof: Data = SwiftProtobuf.Internal.emptyData

  public var previousTransferBlockHeight: UInt64 = 0

  public var exitTransfer: Data = SwiftProtobuf.Internal.emptyData

  public var exitTransferBlockProof: Data = SwiftProtobuf.Internal.emptyData

  public var exitTransferBlockHeight: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PlumChallengeExit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subChainAddress: String = String()

  public var coinID: UInt64 = 0

  public var challengeTransfer: Data = SwiftProtobuf.Internal.emptyData

  public var challengeTransferBlockProof: Data = SwiftProtobuf.Internal.emptyData

  public var challengeTransferBlockHeight: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PlumResponseChallengeExit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subChainAddress: String = String()

  public var coinID: UInt64 = 0

  public var challengeTransfer: Data = SwiftProtobuf.Internal.emptyData

  public var responseTransfer: Data = SwiftProtobuf.Internal.emptyData

  public var responseTransferBlockProof: Data = SwiftProtobuf.Internal.emptyData

  public var previousTransferBlockHeight: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PlumFinalizeExit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subChainAddress: String = String()

  public var coinID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// plum sub chain APIs
public struct Iotextypes_PlumSettleDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coinID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_PlumTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coinID: UInt64 = 0

  public var denomination: Data = SwiftProtobuf.Internal.emptyData

  public var owner: String = String()

  public var recipient: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_ActionCore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var nonce: UInt64 {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var gasLimit: UInt64 {
    get {return _storage._gasLimit}
    set {_uniqueStorage()._gasLimit = newValue}
  }

  public var gasPrice: String {
    get {return _storage._gasPrice}
    set {_uniqueStorage()._gasPrice = newValue}
  }

  public var chainID: UInt32 {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  public var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var transfer: Iotextypes_Transfer {
    get {
      if case .transfer(let v)? = _storage._action {return v}
      return Iotextypes_Transfer()
    }
    set {_uniqueStorage()._action = .transfer(newValue)}
  }

  public var execution: Iotextypes_Execution {
    get {
      if case .execution(let v)? = _storage._action {return v}
      return Iotextypes_Execution()
    }
    set {_uniqueStorage()._action = .execution(newValue)}
  }

  /// FedChain
  public var startSubChain: Iotextypes_StartSubChain {
    get {
      if case .startSubChain(let v)? = _storage._action {return v}
      return Iotextypes_StartSubChain()
    }
    set {_uniqueStorage()._action = .startSubChain(newValue)}
  }

  public var stopSubChain: Iotextypes_StopSubChain {
    get {
      if case .stopSubChain(let v)? = _storage._action {return v}
      return Iotextypes_StopSubChain()
    }
    set {_uniqueStorage()._action = .stopSubChain(newValue)}
  }

  public var putBlock: Iotextypes_PutBlock {
    get {
      if case .putBlock(let v)? = _storage._action {return v}
      return Iotextypes_PutBlock()
    }
    set {_uniqueStorage()._action = .putBlock(newValue)}
  }

  public var createDeposit: Iotextypes_CreateDeposit {
    get {
      if case .createDeposit(let v)? = _storage._action {return v}
      return Iotextypes_CreateDeposit()
    }
    set {_uniqueStorage()._action = .createDeposit(newValue)}
  }

  public var settleDeposit: Iotextypes_SettleDeposit {
    get {
      if case .settleDeposit(let v)? = _storage._action {return v}
      return Iotextypes_SettleDeposit()
    }
    set {_uniqueStorage()._action = .settleDeposit(newValue)}
  }

  /// PlumChain
  public var createPlumChain: Iotextypes_CreatePlumChain {
    get {
      if case .createPlumChain(let v)? = _storage._action {return v}
      return Iotextypes_CreatePlumChain()
    }
    set {_uniqueStorage()._action = .createPlumChain(newValue)}
  }

  public var terminatePlumChain: Iotextypes_TerminatePlumChain {
    get {
      if case .terminatePlumChain(let v)? = _storage._action {return v}
      return Iotextypes_TerminatePlumChain()
    }
    set {_uniqueStorage()._action = .terminatePlumChain(newValue)}
  }

  public var plumPutBlock: Iotextypes_PlumPutBlock {
    get {
      if case .plumPutBlock(let v)? = _storage._action {return v}
      return Iotextypes_PlumPutBlock()
    }
    set {_uniqueStorage()._action = .plumPutBlock(newValue)}
  }

  public var plumCreateDeposit: Iotextypes_PlumCreateDeposit {
    get {
      if case .plumCreateDeposit(let v)? = _storage._action {return v}
      return Iotextypes_PlumCreateDeposit()
    }
    set {_uniqueStorage()._action = .plumCreateDeposit(newValue)}
  }

  public var plumStartExit: Iotextypes_PlumStartExit {
    get {
      if case .plumStartExit(let v)? = _storage._action {return v}
      return Iotextypes_PlumStartExit()
    }
    set {_uniqueStorage()._action = .plumStartExit(newValue)}
  }

  public var plumChallengeExit: Iotextypes_PlumChallengeExit {
    get {
      if case .plumChallengeExit(let v)? = _storage._action {return v}
      return Iotextypes_PlumChallengeExit()
    }
    set {_uniqueStorage()._action = .plumChallengeExit(newValue)}
  }

  public var plumResponseChallengeExit: Iotextypes_PlumResponseChallengeExit {
    get {
      if case .plumResponseChallengeExit(let v)? = _storage._action {return v}
      return Iotextypes_PlumResponseChallengeExit()
    }
    set {_uniqueStorage()._action = .plumResponseChallengeExit(newValue)}
  }

  public var plumFinalizeExit: Iotextypes_PlumFinalizeExit {
    get {
      if case .plumFinalizeExit(let v)? = _storage._action {return v}
      return Iotextypes_PlumFinalizeExit()
    }
    set {_uniqueStorage()._action = .plumFinalizeExit(newValue)}
  }

  public var plumSettleDeposit: Iotextypes_PlumSettleDeposit {
    get {
      if case .plumSettleDeposit(let v)? = _storage._action {return v}
      return Iotextypes_PlumSettleDeposit()
    }
    set {_uniqueStorage()._action = .plumSettleDeposit(newValue)}
  }

  public var plumTransfer: Iotextypes_PlumTransfer {
    get {
      if case .plumTransfer(let v)? = _storage._action {return v}
      return Iotextypes_PlumTransfer()
    }
    set {_uniqueStorage()._action = .plumTransfer(newValue)}
  }

  /// Rewarding protocol actions
  public var depositToRewardingFund: Iotextypes_DepositToRewardingFund {
    get {
      if case .depositToRewardingFund(let v)? = _storage._action {return v}
      return Iotextypes_DepositToRewardingFund()
    }
    set {_uniqueStorage()._action = .depositToRewardingFund(newValue)}
  }

  public var claimFromRewardingFund: Iotextypes_ClaimFromRewardingFund {
    get {
      if case .claimFromRewardingFund(let v)? = _storage._action {return v}
      return Iotextypes_ClaimFromRewardingFund()
    }
    set {_uniqueStorage()._action = .claimFromRewardingFund(newValue)}
  }

  public var grantReward: Iotextypes_GrantReward {
    get {
      if case .grantReward(let v)? = _storage._action {return v}
      return Iotextypes_GrantReward()
    }
    set {_uniqueStorage()._action = .grantReward(newValue)}
  }

  /// Native staking
  public var stakeCreate: Iotextypes_StakeCreate {
    get {
      if case .stakeCreate(let v)? = _storage._action {return v}
      return Iotextypes_StakeCreate()
    }
    set {_uniqueStorage()._action = .stakeCreate(newValue)}
  }

  public var stakeUnstake: Iotextypes_StakeReclaim {
    get {
      if case .stakeUnstake(let v)? = _storage._action {return v}
      return Iotextypes_StakeReclaim()
    }
    set {_uniqueStorage()._action = .stakeUnstake(newValue)}
  }

  public var stakeWithdraw: Iotextypes_StakeReclaim {
    get {
      if case .stakeWithdraw(let v)? = _storage._action {return v}
      return Iotextypes_StakeReclaim()
    }
    set {_uniqueStorage()._action = .stakeWithdraw(newValue)}
  }

  public var stakeAddDeposit: Iotextypes_StakeAddDeposit {
    get {
      if case .stakeAddDeposit(let v)? = _storage._action {return v}
      return Iotextypes_StakeAddDeposit()
    }
    set {_uniqueStorage()._action = .stakeAddDeposit(newValue)}
  }

  public var stakeRestake: Iotextypes_StakeRestake {
    get {
      if case .stakeRestake(let v)? = _storage._action {return v}
      return Iotextypes_StakeRestake()
    }
    set {_uniqueStorage()._action = .stakeRestake(newValue)}
  }

  public var stakeChangeCandidate: Iotextypes_StakeChangeCandidate {
    get {
      if case .stakeChangeCandidate(let v)? = _storage._action {return v}
      return Iotextypes_StakeChangeCandidate()
    }
    set {_uniqueStorage()._action = .stakeChangeCandidate(newValue)}
  }

  public var stakeTransferOwnership: Iotextypes_StakeTransferOwnership {
    get {
      if case .stakeTransferOwnership(let v)? = _storage._action {return v}
      return Iotextypes_StakeTransferOwnership()
    }
    set {_uniqueStorage()._action = .stakeTransferOwnership(newValue)}
  }

  public var candidateRegister: Iotextypes_CandidateRegister {
    get {
      if case .candidateRegister(let v)? = _storage._action {return v}
      return Iotextypes_CandidateRegister()
    }
    set {_uniqueStorage()._action = .candidateRegister(newValue)}
  }

  public var candidateUpdate: Iotextypes_CandidateBasicInfo {
    get {
      if case .candidateUpdate(let v)? = _storage._action {return v}
      return Iotextypes_CandidateBasicInfo()
    }
    set {_uniqueStorage()._action = .candidateUpdate(newValue)}
  }

  public var putPollResult: Iotextypes_PutPollResult {
    get {
      if case .putPollResult(let v)? = _storage._action {return v}
      return Iotextypes_PutPollResult()
    }
    set {_uniqueStorage()._action = .putPollResult(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    case transfer(Iotextypes_Transfer)
    case execution(Iotextypes_Execution)
    /// FedChain
    case startSubChain(Iotextypes_StartSubChain)
    case stopSubChain(Iotextypes_StopSubChain)
    case putBlock(Iotextypes_PutBlock)
    case createDeposit(Iotextypes_CreateDeposit)
    case settleDeposit(Iotextypes_SettleDeposit)
    /// PlumChain
    case createPlumChain(Iotextypes_CreatePlumChain)
    case terminatePlumChain(Iotextypes_TerminatePlumChain)
    case plumPutBlock(Iotextypes_PlumPutBlock)
    case plumCreateDeposit(Iotextypes_PlumCreateDeposit)
    case plumStartExit(Iotextypes_PlumStartExit)
    case plumChallengeExit(Iotextypes_PlumChallengeExit)
    case plumResponseChallengeExit(Iotextypes_PlumResponseChallengeExit)
    case plumFinalizeExit(Iotextypes_PlumFinalizeExit)
    case plumSettleDeposit(Iotextypes_PlumSettleDeposit)
    case plumTransfer(Iotextypes_PlumTransfer)
    /// Rewarding protocol actions
    case depositToRewardingFund(Iotextypes_DepositToRewardingFund)
    case claimFromRewardingFund(Iotextypes_ClaimFromRewardingFund)
    case grantReward(Iotextypes_GrantReward)
    /// Native staking
    case stakeCreate(Iotextypes_StakeCreate)
    case stakeUnstake(Iotextypes_StakeReclaim)
    case stakeWithdraw(Iotextypes_StakeReclaim)
    case stakeAddDeposit(Iotextypes_StakeAddDeposit)
    case stakeRestake(Iotextypes_StakeRestake)
    case stakeChangeCandidate(Iotextypes_StakeChangeCandidate)
    case stakeTransferOwnership(Iotextypes_StakeTransferOwnership)
    case candidateRegister(Iotextypes_CandidateRegister)
    case candidateUpdate(Iotextypes_CandidateBasicInfo)
    case putPollResult(Iotextypes_PutPollResult)

  #if !swift(>=4.1)
    public static func ==(lhs: Iotextypes_ActionCore.OneOf_Action, rhs: Iotextypes_ActionCore.OneOf_Action) -> Bool {
      switch (lhs, rhs) {
      case (.transfer(let l), .transfer(let r)): return l == r
      case (.execution(let l), .execution(let r)): return l == r
      case (.startSubChain(let l), .startSubChain(let r)): return l == r
      case (.stopSubChain(let l), .stopSubChain(let r)): return l == r
      case (.putBlock(let l), .putBlock(let r)): return l == r
      case (.createDeposit(let l), .createDeposit(let r)): return l == r
      case (.settleDeposit(let l), .settleDeposit(let r)): return l == r
      case (.createPlumChain(let l), .createPlumChain(let r)): return l == r
      case (.terminatePlumChain(let l), .terminatePlumChain(let r)): return l == r
      case (.plumPutBlock(let l), .plumPutBlock(let r)): return l == r
      case (.plumCreateDeposit(let l), .plumCreateDeposit(let r)): return l == r
      case (.plumStartExit(let l), .plumStartExit(let r)): return l == r
      case (.plumChallengeExit(let l), .plumChallengeExit(let r)): return l == r
      case (.plumResponseChallengeExit(let l), .plumResponseChallengeExit(let r)): return l == r
      case (.plumFinalizeExit(let l), .plumFinalizeExit(let r)): return l == r
      case (.plumSettleDeposit(let l), .plumSettleDeposit(let r)): return l == r
      case (.plumTransfer(let l), .plumTransfer(let r)): return l == r
      case (.depositToRewardingFund(let l), .depositToRewardingFund(let r)): return l == r
      case (.claimFromRewardingFund(let l), .claimFromRewardingFund(let r)): return l == r
      case (.grantReward(let l), .grantReward(let r)): return l == r
      case (.stakeCreate(let l), .stakeCreate(let r)): return l == r
      case (.stakeUnstake(let l), .stakeUnstake(let r)): return l == r
      case (.stakeWithdraw(let l), .stakeWithdraw(let r)): return l == r
      case (.stakeAddDeposit(let l), .stakeAddDeposit(let r)): return l == r
      case (.stakeRestake(let l), .stakeRestake(let r)): return l == r
      case (.stakeChangeCandidate(let l), .stakeChangeCandidate(let r)): return l == r
      case (.stakeTransferOwnership(let l), .stakeTransferOwnership(let r)): return l == r
      case (.candidateRegister(let l), .candidateRegister(let r)): return l == r
      case (.candidateUpdate(let l), .candidateUpdate(let r)): return l == r
      case (.putPollResult(let l), .putPollResult(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Iotextypes_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var core: Iotextypes_ActionCore {
    get {return _storage._core ?? Iotextypes_ActionCore()}
    set {_uniqueStorage()._core = newValue}
  }
  /// Returns true if `core` has been explicitly set.
  public var hasCore: Bool {return _storage._core != nil}
  /// Clears the value of `core`. Subsequent reads from it will return its default value.
  public mutating func clearCore() {_uniqueStorage()._core = nil}

  public var senderPubKey: Data {
    get {return _storage._senderPubKey}
    set {_uniqueStorage()._senderPubKey = newValue}
  }

  public var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  public var encoding: Iotextypes_Encoding {
    get {return _storage._encoding}
    set {_uniqueStorage()._encoding = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Iotextypes_Receipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: UInt64 = 0

  public var blkHeight: UInt64 = 0

  public var actHash: Data = SwiftProtobuf.Internal.emptyData

  public var gasConsumed: UInt64 = 0

  public var contractAddress: String = String()

  public var logs: [Iotextypes_Log] = []

  public var executionRevertMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_Log {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contractAddress: String = String()

  public var topics: [Data] = []

  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var blkHeight: UInt64 = 0

  public var actHash: Data = SwiftProtobuf.Internal.emptyData

  public var index: UInt32 = 0

  public var blkHash: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_Logs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var logs: [Iotextypes_Log] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Deprecated
public struct Iotextypes_EvmTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: Data = SwiftProtobuf.Internal.emptyData

  public var from: String = String()

  public var to: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Deprecated
public struct Iotextypes_EvmTransferList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var evmTransfers: [Iotextypes_EvmTransfer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Deprecated
public struct Iotextypes_ActionEvmTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionHash: Data = SwiftProtobuf.Internal.emptyData

  public var numEvmTransfers: UInt64 = 0

  public var evmTransfers: [Iotextypes_EvmTransfer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Deprecated
public struct Iotextypes_BlockEvmTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockHeight: UInt64 = 0

  public var numEvmTransfers: UInt64 = 0

  public var actionEvmTransfers: [Iotextypes_ActionEvmTransfer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_DepositToRewardingFund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: String = String()

  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_ClaimFromRewardingFund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: String = String()

  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_GrantReward {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Iotextypes_RewardType = .blockReward

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iotextypes"

extension Iotextypes_Encoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IOTEX_PROTOBUF"),
    1: .same(proto: "ETHEREUM_RLP"),
  ]
}

extension Iotextypes_RewardType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BlockReward"),
    1: .same(proto: "EpochReward"),
  ]
}

extension Iotextypes_Transfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "recipient"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.amount)
      case 2: try decoder.decodeSingularStringField(value: &self.recipient)
      case 3: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Transfer, rhs: Iotextypes_Transfer) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_Candidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Candidate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "votes"),
    3: .same(proto: "pubKey"),
    4: .same(proto: "rewardAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularBytesField(value: &self.votes)
      case 3: try decoder.decodeSingularBytesField(value: &self.pubKey)
      case 4: try decoder.decodeSingularStringField(value: &self.rewardAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitSingularBytesField(value: self.votes, fieldNumber: 2)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 3)
    }
    if !self.rewardAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAddress, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Candidate, rhs: Iotextypes_Candidate) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.rewardAddress != rhs.rewardAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_CandidateList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidateList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candidates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.candidates)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candidates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candidates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_CandidateList, rhs: Iotextypes_CandidateList) -> Bool {
    if lhs.candidates != rhs.candidates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PutPollResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutPollResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "candidates"),
  ]

  fileprivate class _StorageClass {
    var _height: UInt64 = 0
    var _candidates: Iotextypes_CandidateList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _candidates = source._candidates
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._candidates)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 1)
      }
      if let v = _storage._candidates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PutPollResult, rhs: Iotextypes_PutPollResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._candidates != rhs_storage._candidates {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_Execution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Execution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "contract"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.amount)
      case 2: try decoder.decodeSingularStringField(value: &self.contract)
      case 3: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Execution, rhs: Iotextypes_Execution) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_StakeCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candidateName"),
    2: .same(proto: "stakedAmount"),
    3: .same(proto: "stakedDuration"),
    4: .same(proto: "autoStake"),
    5: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.candidateName)
      case 2: try decoder.decodeSingularStringField(value: &self.stakedAmount)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.stakedDuration)
      case 4: try decoder.decodeSingularBoolField(value: &self.autoStake)
      case 5: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candidateName.isEmpty {
      try visitor.visitSingularStringField(value: self.candidateName, fieldNumber: 1)
    }
    if !self.stakedAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.stakedAmount, fieldNumber: 2)
    }
    if self.stakedDuration != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakedDuration, fieldNumber: 3)
    }
    if self.autoStake != false {
      try visitor.visitSingularBoolField(value: self.autoStake, fieldNumber: 4)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_StakeCreate, rhs: Iotextypes_StakeCreate) -> Bool {
    if lhs.candidateName != rhs.candidateName {return false}
    if lhs.stakedAmount != rhs.stakedAmount {return false}
    if lhs.stakedDuration != rhs.stakedDuration {return false}
    if lhs.autoStake != rhs.autoStake {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_StakeReclaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeReclaim"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucketIndex"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.bucketIndex)
      case 2: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.bucketIndex, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_StakeReclaim, rhs: Iotextypes_StakeReclaim) -> Bool {
    if lhs.bucketIndex != rhs.bucketIndex {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_StakeAddDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeAddDeposit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucketIndex"),
    2: .same(proto: "amount"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.bucketIndex)
      case 2: try decoder.decodeSingularStringField(value: &self.amount)
      case 3: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.bucketIndex, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_StakeAddDeposit, rhs: Iotextypes_StakeAddDeposit) -> Bool {
    if lhs.bucketIndex != rhs.bucketIndex {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_StakeRestake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeRestake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucketIndex"),
    2: .same(proto: "stakedDuration"),
    3: .same(proto: "autoStake"),
    4: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.bucketIndex)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.stakedDuration)
      case 3: try decoder.decodeSingularBoolField(value: &self.autoStake)
      case 4: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.bucketIndex, fieldNumber: 1)
    }
    if self.stakedDuration != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakedDuration, fieldNumber: 2)
    }
    if self.autoStake != false {
      try visitor.visitSingularBoolField(value: self.autoStake, fieldNumber: 3)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_StakeRestake, rhs: Iotextypes_StakeRestake) -> Bool {
    if lhs.bucketIndex != rhs.bucketIndex {return false}
    if lhs.stakedDuration != rhs.stakedDuration {return false}
    if lhs.autoStake != rhs.autoStake {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_StakeChangeCandidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeChangeCandidate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucketIndex"),
    2: .same(proto: "candidateName"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.bucketIndex)
      case 2: try decoder.decodeSingularStringField(value: &self.candidateName)
      case 3: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.bucketIndex, fieldNumber: 1)
    }
    if !self.candidateName.isEmpty {
      try visitor.visitSingularStringField(value: self.candidateName, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_StakeChangeCandidate, rhs: Iotextypes_StakeChangeCandidate) -> Bool {
    if lhs.bucketIndex != rhs.bucketIndex {return false}
    if lhs.candidateName != rhs.candidateName {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_StakeTransferOwnership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeTransferOwnership"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucketIndex"),
    2: .same(proto: "voterAddress"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.bucketIndex)
      case 2: try decoder.decodeSingularStringField(value: &self.voterAddress)
      case 3: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.bucketIndex, fieldNumber: 1)
    }
    if !self.voterAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.voterAddress, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_StakeTransferOwnership, rhs: Iotextypes_StakeTransferOwnership) -> Bool {
    if lhs.bucketIndex != rhs.bucketIndex {return false}
    if lhs.voterAddress != rhs.voterAddress {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_CandidateBasicInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidateBasicInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "operatorAddress"),
    3: .same(proto: "rewardAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.operatorAddress)
      case 3: try decoder.decodeSingularStringField(value: &self.rewardAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.operatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.operatorAddress, fieldNumber: 2)
    }
    if !self.rewardAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_CandidateBasicInfo, rhs: Iotextypes_CandidateBasicInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.operatorAddress != rhs.operatorAddress {return false}
    if lhs.rewardAddress != rhs.rewardAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_CandidateRegister: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidateRegister"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candidate"),
    2: .same(proto: "stakedAmount"),
    3: .same(proto: "stakedDuration"),
    4: .same(proto: "autoStake"),
    5: .same(proto: "ownerAddress"),
    6: .same(proto: "payload"),
  ]

  fileprivate class _StorageClass {
    var _candidate: Iotextypes_CandidateBasicInfo? = nil
    var _stakedAmount: String = String()
    var _stakedDuration: UInt32 = 0
    var _autoStake: Bool = false
    var _ownerAddress: String = String()
    var _payload: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _candidate = source._candidate
      _stakedAmount = source._stakedAmount
      _stakedDuration = source._stakedDuration
      _autoStake = source._autoStake
      _ownerAddress = source._ownerAddress
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._candidate)
        case 2: try decoder.decodeSingularStringField(value: &_storage._stakedAmount)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._stakedDuration)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._autoStake)
        case 5: try decoder.decodeSingularStringField(value: &_storage._ownerAddress)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._payload)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._candidate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._stakedAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stakedAmount, fieldNumber: 2)
      }
      if _storage._stakedDuration != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._stakedDuration, fieldNumber: 3)
      }
      if _storage._autoStake != false {
        try visitor.visitSingularBoolField(value: _storage._autoStake, fieldNumber: 4)
      }
      if !_storage._ownerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerAddress, fieldNumber: 5)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_CandidateRegister, rhs: Iotextypes_CandidateRegister) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._candidate != rhs_storage._candidate {return false}
        if _storage._stakedAmount != rhs_storage._stakedAmount {return false}
        if _storage._stakedDuration != rhs_storage._stakedDuration {return false}
        if _storage._autoStake != rhs_storage._autoStake {return false}
        if _storage._ownerAddress != rhs_storage._ownerAddress {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_StartSubChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartSubChain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainID"),
    2: .same(proto: "securityDeposit"),
    3: .same(proto: "operationDeposit"),
    4: .same(proto: "startHeight"),
    5: .same(proto: "parentHeightOffset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.chainID)
      case 2: try decoder.decodeSingularStringField(value: &self.securityDeposit)
      case 3: try decoder.decodeSingularStringField(value: &self.operationDeposit)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.startHeight)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.parentHeightOffset)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chainID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chainID, fieldNumber: 1)
    }
    if !self.securityDeposit.isEmpty {
      try visitor.visitSingularStringField(value: self.securityDeposit, fieldNumber: 2)
    }
    if !self.operationDeposit.isEmpty {
      try visitor.visitSingularStringField(value: self.operationDeposit, fieldNumber: 3)
    }
    if self.startHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.startHeight, fieldNumber: 4)
    }
    if self.parentHeightOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.parentHeightOffset, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_StartSubChain, rhs: Iotextypes_StartSubChain) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.securityDeposit != rhs.securityDeposit {return false}
    if lhs.operationDeposit != rhs.operationDeposit {return false}
    if lhs.startHeight != rhs.startHeight {return false}
    if lhs.parentHeightOffset != rhs.parentHeightOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_StopSubChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopSubChain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainID"),
    2: .same(proto: "stopHeight"),
    3: .same(proto: "subChainAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.chainID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.stopHeight)
      case 3: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chainID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chainID, fieldNumber: 1)
    }
    if self.stopHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.stopHeight, fieldNumber: 2)
    }
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_StopSubChain, rhs: Iotextypes_StopSubChain) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.stopHeight != rhs.stopHeight {return false}
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_MerkleRoot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MerkleRoot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularBytesField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_MerkleRoot, rhs: Iotextypes_MerkleRoot) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PutBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subChainAddress"),
    2: .same(proto: "height"),
    3: .same(proto: "roots"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.height)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.roots)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if !self.roots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roots, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PutBlock, rhs: Iotextypes_PutBlock) -> Bool {
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.height != rhs.height {return false}
    if lhs.roots != rhs.roots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_CreateDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDeposit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainID"),
    2: .same(proto: "amount"),
    3: .same(proto: "recipient"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.chainID)
      case 2: try decoder.decodeSingularStringField(value: &self.amount)
      case 3: try decoder.decodeSingularStringField(value: &self.recipient)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chainID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chainID, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_CreateDeposit, rhs: Iotextypes_CreateDeposit) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_SettleDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SettleDeposit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "recipient"),
    3: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.amount)
      case 2: try decoder.decodeSingularStringField(value: &self.recipient)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.index)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_SettleDeposit, rhs: Iotextypes_SettleDeposit) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_CreatePlumChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePlumChain"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_CreatePlumChain, rhs: Iotextypes_CreatePlumChain) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_TerminatePlumChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminatePlumChain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subChainAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_TerminatePlumChain, rhs: Iotextypes_TerminatePlumChain) -> Bool {
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PlumPutBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlumPutBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subChainAddress"),
    2: .same(proto: "height"),
    3: .same(proto: "roots"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.height)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.roots)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if !self.roots.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.roots, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PlumPutBlock, rhs: Iotextypes_PlumPutBlock) -> Bool {
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.height != rhs.height {return false}
    if lhs.roots != rhs.roots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PlumCreateDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlumCreateDeposit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subChainAddress"),
    2: .same(proto: "amount"),
    3: .same(proto: "recipient"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      case 2: try decoder.decodeSingularStringField(value: &self.amount)
      case 3: try decoder.decodeSingularStringField(value: &self.recipient)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PlumCreateDeposit, rhs: Iotextypes_PlumCreateDeposit) -> Bool {
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PlumStartExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlumStartExit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subChainAddress"),
    2: .same(proto: "previousTransfer"),
    3: .same(proto: "previousTransferBlockProof"),
    4: .same(proto: "previousTransferBlockHeight"),
    5: .same(proto: "exitTransfer"),
    6: .same(proto: "exitTransferBlockProof"),
    7: .same(proto: "exitTransferBlockHeight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.previousTransfer)
      case 3: try decoder.decodeSingularBytesField(value: &self.previousTransferBlockProof)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.previousTransferBlockHeight)
      case 5: try decoder.decodeSingularBytesField(value: &self.exitTransfer)
      case 6: try decoder.decodeSingularBytesField(value: &self.exitTransferBlockProof)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.exitTransferBlockHeight)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 1)
    }
    if !self.previousTransfer.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousTransfer, fieldNumber: 2)
    }
    if !self.previousTransferBlockProof.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousTransferBlockProof, fieldNumber: 3)
    }
    if self.previousTransferBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.previousTransferBlockHeight, fieldNumber: 4)
    }
    if !self.exitTransfer.isEmpty {
      try visitor.visitSingularBytesField(value: self.exitTransfer, fieldNumber: 5)
    }
    if !self.exitTransferBlockProof.isEmpty {
      try visitor.visitSingularBytesField(value: self.exitTransferBlockProof, fieldNumber: 6)
    }
    if self.exitTransferBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.exitTransferBlockHeight, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PlumStartExit, rhs: Iotextypes_PlumStartExit) -> Bool {
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.previousTransfer != rhs.previousTransfer {return false}
    if lhs.previousTransferBlockProof != rhs.previousTransferBlockProof {return false}
    if lhs.previousTransferBlockHeight != rhs.previousTransferBlockHeight {return false}
    if lhs.exitTransfer != rhs.exitTransfer {return false}
    if lhs.exitTransferBlockProof != rhs.exitTransferBlockProof {return false}
    if lhs.exitTransferBlockHeight != rhs.exitTransferBlockHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PlumChallengeExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlumChallengeExit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subChainAddress"),
    2: .same(proto: "coinID"),
    3: .same(proto: "challengeTransfer"),
    4: .same(proto: "challengeTransferBlockProof"),
    5: .same(proto: "challengeTransferBlockHeight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.coinID)
      case 3: try decoder.decodeSingularBytesField(value: &self.challengeTransfer)
      case 4: try decoder.decodeSingularBytesField(value: &self.challengeTransferBlockProof)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.challengeTransferBlockHeight)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 1)
    }
    if self.coinID != 0 {
      try visitor.visitSingularUInt64Field(value: self.coinID, fieldNumber: 2)
    }
    if !self.challengeTransfer.isEmpty {
      try visitor.visitSingularBytesField(value: self.challengeTransfer, fieldNumber: 3)
    }
    if !self.challengeTransferBlockProof.isEmpty {
      try visitor.visitSingularBytesField(value: self.challengeTransferBlockProof, fieldNumber: 4)
    }
    if self.challengeTransferBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.challengeTransferBlockHeight, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PlumChallengeExit, rhs: Iotextypes_PlumChallengeExit) -> Bool {
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.coinID != rhs.coinID {return false}
    if lhs.challengeTransfer != rhs.challengeTransfer {return false}
    if lhs.challengeTransferBlockProof != rhs.challengeTransferBlockProof {return false}
    if lhs.challengeTransferBlockHeight != rhs.challengeTransferBlockHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PlumResponseChallengeExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlumResponseChallengeExit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subChainAddress"),
    2: .same(proto: "coinID"),
    3: .same(proto: "challengeTransfer"),
    4: .same(proto: "responseTransfer"),
    5: .same(proto: "responseTransferBlockProof"),
    6: .same(proto: "previousTransferBlockHeight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.coinID)
      case 3: try decoder.decodeSingularBytesField(value: &self.challengeTransfer)
      case 4: try decoder.decodeSingularBytesField(value: &self.responseTransfer)
      case 5: try decoder.decodeSingularBytesField(value: &self.responseTransferBlockProof)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.previousTransferBlockHeight)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 1)
    }
    if self.coinID != 0 {
      try visitor.visitSingularUInt64Field(value: self.coinID, fieldNumber: 2)
    }
    if !self.challengeTransfer.isEmpty {
      try visitor.visitSingularBytesField(value: self.challengeTransfer, fieldNumber: 3)
    }
    if !self.responseTransfer.isEmpty {
      try visitor.visitSingularBytesField(value: self.responseTransfer, fieldNumber: 4)
    }
    if !self.responseTransferBlockProof.isEmpty {
      try visitor.visitSingularBytesField(value: self.responseTransferBlockProof, fieldNumber: 5)
    }
    if self.previousTransferBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.previousTransferBlockHeight, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PlumResponseChallengeExit, rhs: Iotextypes_PlumResponseChallengeExit) -> Bool {
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.coinID != rhs.coinID {return false}
    if lhs.challengeTransfer != rhs.challengeTransfer {return false}
    if lhs.responseTransfer != rhs.responseTransfer {return false}
    if lhs.responseTransferBlockProof != rhs.responseTransferBlockProof {return false}
    if lhs.previousTransferBlockHeight != rhs.previousTransferBlockHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PlumFinalizeExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlumFinalizeExit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subChainAddress"),
    2: .same(proto: "coinID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subChainAddress)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.coinID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subChainAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subChainAddress, fieldNumber: 1)
    }
    if self.coinID != 0 {
      try visitor.visitSingularUInt64Field(value: self.coinID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PlumFinalizeExit, rhs: Iotextypes_PlumFinalizeExit) -> Bool {
    if lhs.subChainAddress != rhs.subChainAddress {return false}
    if lhs.coinID != rhs.coinID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PlumSettleDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlumSettleDeposit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coinID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.coinID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coinID != 0 {
      try visitor.visitSingularUInt64Field(value: self.coinID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PlumSettleDeposit, rhs: Iotextypes_PlumSettleDeposit) -> Bool {
    if lhs.coinID != rhs.coinID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_PlumTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlumTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coinID"),
    2: .same(proto: "denomination"),
    3: .same(proto: "owner"),
    4: .same(proto: "recipient"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.coinID)
      case 2: try decoder.decodeSingularBytesField(value: &self.denomination)
      case 3: try decoder.decodeSingularStringField(value: &self.owner)
      case 4: try decoder.decodeSingularStringField(value: &self.recipient)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coinID != 0 {
      try visitor.visitSingularUInt64Field(value: self.coinID, fieldNumber: 1)
    }
    if !self.denomination.isEmpty {
      try visitor.visitSingularBytesField(value: self.denomination, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_PlumTransfer, rhs: Iotextypes_PlumTransfer) -> Bool {
    if lhs.coinID != rhs.coinID {return false}
    if lhs.denomination != rhs.denomination {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_ActionCore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionCore"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "nonce"),
    3: .same(proto: "gasLimit"),
    4: .same(proto: "gasPrice"),
    5: .same(proto: "chainID"),
    10: .same(proto: "transfer"),
    12: .same(proto: "execution"),
    13: .same(proto: "startSubChain"),
    14: .same(proto: "stopSubChain"),
    15: .same(proto: "putBlock"),
    16: .same(proto: "createDeposit"),
    17: .same(proto: "settleDeposit"),
    18: .same(proto: "createPlumChain"),
    19: .same(proto: "terminatePlumChain"),
    20: .same(proto: "plumPutBlock"),
    21: .same(proto: "plumCreateDeposit"),
    22: .same(proto: "plumStartExit"),
    23: .same(proto: "plumChallengeExit"),
    24: .same(proto: "plumResponseChallengeExit"),
    25: .same(proto: "plumFinalizeExit"),
    26: .same(proto: "plumSettleDeposit"),
    27: .same(proto: "plumTransfer"),
    30: .same(proto: "depositToRewardingFund"),
    31: .same(proto: "claimFromRewardingFund"),
    32: .same(proto: "grantReward"),
    40: .same(proto: "stakeCreate"),
    41: .same(proto: "stakeUnstake"),
    42: .same(proto: "stakeWithdraw"),
    43: .same(proto: "stakeAddDeposit"),
    44: .same(proto: "stakeRestake"),
    45: .same(proto: "stakeChangeCandidate"),
    46: .same(proto: "stakeTransferOwnership"),
    47: .same(proto: "candidateRegister"),
    48: .same(proto: "candidateUpdate"),
    50: .same(proto: "putPollResult"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt32 = 0
    var _nonce: UInt64 = 0
    var _gasLimit: UInt64 = 0
    var _gasPrice: String = String()
    var _chainID: UInt32 = 0
    var _action: Iotextypes_ActionCore.OneOf_Action?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _nonce = source._nonce
      _gasLimit = source._gasLimit
      _gasPrice = source._gasPrice
      _chainID = source._chainID
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._version)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._nonce)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._gasLimit)
        case 4: try decoder.decodeSingularStringField(value: &_storage._gasPrice)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._chainID)
        case 10:
          var v: Iotextypes_Transfer?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .transfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .transfer(v)}
        case 12:
          var v: Iotextypes_Execution?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .execution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .execution(v)}
        case 13:
          var v: Iotextypes_StartSubChain?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .startSubChain(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .startSubChain(v)}
        case 14:
          var v: Iotextypes_StopSubChain?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .stopSubChain(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .stopSubChain(v)}
        case 15:
          var v: Iotextypes_PutBlock?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .putBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .putBlock(v)}
        case 16:
          var v: Iotextypes_CreateDeposit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .createDeposit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .createDeposit(v)}
        case 17:
          var v: Iotextypes_SettleDeposit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .settleDeposit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .settleDeposit(v)}
        case 18:
          var v: Iotextypes_CreatePlumChain?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .createPlumChain(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .createPlumChain(v)}
        case 19:
          var v: Iotextypes_TerminatePlumChain?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .terminatePlumChain(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .terminatePlumChain(v)}
        case 20:
          var v: Iotextypes_PlumPutBlock?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .plumPutBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .plumPutBlock(v)}
        case 21:
          var v: Iotextypes_PlumCreateDeposit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .plumCreateDeposit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .plumCreateDeposit(v)}
        case 22:
          var v: Iotextypes_PlumStartExit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .plumStartExit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .plumStartExit(v)}
        case 23:
          var v: Iotextypes_PlumChallengeExit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .plumChallengeExit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .plumChallengeExit(v)}
        case 24:
          var v: Iotextypes_PlumResponseChallengeExit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .plumResponseChallengeExit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .plumResponseChallengeExit(v)}
        case 25:
          var v: Iotextypes_PlumFinalizeExit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .plumFinalizeExit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .plumFinalizeExit(v)}
        case 26:
          var v: Iotextypes_PlumSettleDeposit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .plumSettleDeposit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .plumSettleDeposit(v)}
        case 27:
          var v: Iotextypes_PlumTransfer?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .plumTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .plumTransfer(v)}
        case 30:
          var v: Iotextypes_DepositToRewardingFund?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .depositToRewardingFund(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .depositToRewardingFund(v)}
        case 31:
          var v: Iotextypes_ClaimFromRewardingFund?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .claimFromRewardingFund(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .claimFromRewardingFund(v)}
        case 32:
          var v: Iotextypes_GrantReward?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .grantReward(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .grantReward(v)}
        case 40:
          var v: Iotextypes_StakeCreate?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .stakeCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .stakeCreate(v)}
        case 41:
          var v: Iotextypes_StakeReclaim?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .stakeUnstake(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .stakeUnstake(v)}
        case 42:
          var v: Iotextypes_StakeReclaim?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .stakeWithdraw(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .stakeWithdraw(v)}
        case 43:
          var v: Iotextypes_StakeAddDeposit?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .stakeAddDeposit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .stakeAddDeposit(v)}
        case 44:
          var v: Iotextypes_StakeRestake?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .stakeRestake(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .stakeRestake(v)}
        case 45:
          var v: Iotextypes_StakeChangeCandidate?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .stakeChangeCandidate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .stakeChangeCandidate(v)}
        case 46:
          var v: Iotextypes_StakeTransferOwnership?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .stakeTransferOwnership(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .stakeTransferOwnership(v)}
        case 47:
          var v: Iotextypes_CandidateRegister?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .candidateRegister(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .candidateRegister(v)}
        case 48:
          var v: Iotextypes_CandidateBasicInfo?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .candidateUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .candidateUpdate(v)}
        case 50:
          var v: Iotextypes_PutPollResult?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .putPollResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .putPollResult(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if _storage._nonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nonce, fieldNumber: 2)
      }
      if _storage._gasLimit != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gasLimit, fieldNumber: 3)
      }
      if !_storage._gasPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gasPrice, fieldNumber: 4)
      }
      if _storage._chainID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._chainID, fieldNumber: 5)
      }
      switch _storage._action {
      case .transfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .execution(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .startSubChain(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .stopSubChain(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .putBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .createDeposit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .settleDeposit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .createPlumChain(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .terminatePlumChain(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .plumPutBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .plumCreateDeposit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .plumStartExit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .plumChallengeExit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .plumResponseChallengeExit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .plumFinalizeExit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .plumSettleDeposit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .plumTransfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .depositToRewardingFund(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .claimFromRewardingFund(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .grantReward(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      case .stakeCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      case .stakeUnstake(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      case .stakeWithdraw(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      case .stakeAddDeposit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      case .stakeRestake(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      case .stakeChangeCandidate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      case .stakeTransferOwnership(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      case .candidateRegister(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      case .candidateUpdate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      case .putPollResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_ActionCore, rhs: Iotextypes_ActionCore) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._gasLimit != rhs_storage._gasLimit {return false}
        if _storage._gasPrice != rhs_storage._gasPrice {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "core"),
    2: .same(proto: "senderPubKey"),
    3: .same(proto: "signature"),
    4: .same(proto: "encoding"),
  ]

  fileprivate class _StorageClass {
    var _core: Iotextypes_ActionCore? = nil
    var _senderPubKey: Data = SwiftProtobuf.Internal.emptyData
    var _signature: Data = SwiftProtobuf.Internal.emptyData
    var _encoding: Iotextypes_Encoding = .iotexProtobuf

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _core = source._core
      _senderPubKey = source._senderPubKey
      _signature = source._signature
      _encoding = source._encoding
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._core)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._senderPubKey)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._signature)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._encoding)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._core {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._senderPubKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._senderPubKey, fieldNumber: 2)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 3)
      }
      if _storage._encoding != .iotexProtobuf {
        try visitor.visitSingularEnumField(value: _storage._encoding, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Action, rhs: Iotextypes_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._core != rhs_storage._core {return false}
        if _storage._senderPubKey != rhs_storage._senderPubKey {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._encoding != rhs_storage._encoding {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_Receipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Receipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "blkHeight"),
    3: .same(proto: "actHash"),
    4: .same(proto: "gasConsumed"),
    5: .same(proto: "contractAddress"),
    6: .same(proto: "logs"),
    7: .same(proto: "executionRevertMsg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.status)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.blkHeight)
      case 3: try decoder.decodeSingularBytesField(value: &self.actHash)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.gasConsumed)
      case 5: try decoder.decodeSingularStringField(value: &self.contractAddress)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.logs)
      case 7: try decoder.decodeSingularStringField(value: &self.executionRevertMsg)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularUInt64Field(value: self.status, fieldNumber: 1)
    }
    if self.blkHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blkHeight, fieldNumber: 2)
    }
    if !self.actHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.actHash, fieldNumber: 3)
    }
    if self.gasConsumed != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasConsumed, fieldNumber: 4)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 5)
    }
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 6)
    }
    if !self.executionRevertMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.executionRevertMsg, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Receipt, rhs: Iotextypes_Receipt) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.blkHeight != rhs.blkHeight {return false}
    if lhs.actHash != rhs.actHash {return false}
    if lhs.gasConsumed != rhs.gasConsumed {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.executionRevertMsg != rhs.executionRevertMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Log"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractAddress"),
    2: .same(proto: "topics"),
    3: .same(proto: "data"),
    4: .same(proto: "blkHeight"),
    5: .same(proto: "actHash"),
    6: .same(proto: "index"),
    7: .same(proto: "blkHash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.contractAddress)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.topics)
      case 3: try decoder.decodeSingularBytesField(value: &self.data)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.blkHeight)
      case 5: try decoder.decodeSingularBytesField(value: &self.actHash)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.index)
      case 7: try decoder.decodeSingularBytesField(value: &self.blkHash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 1)
    }
    if !self.topics.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.topics, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if self.blkHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blkHeight, fieldNumber: 4)
    }
    if !self.actHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.actHash, fieldNumber: 5)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 6)
    }
    if !self.blkHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blkHash, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Log, rhs: Iotextypes_Log) -> Bool {
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs.data != rhs.data {return false}
    if lhs.blkHeight != rhs.blkHeight {return false}
    if lhs.actHash != rhs.actHash {return false}
    if lhs.index != rhs.index {return false}
    if lhs.blkHash != rhs.blkHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_Logs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Logs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.logs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Logs, rhs: Iotextypes_Logs) -> Bool {
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_EvmTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvmTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.amount)
      case 2: try decoder.decodeSingularStringField(value: &self.from)
      case 3: try decoder.decodeSingularStringField(value: &self.to)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularBytesField(value: self.amount, fieldNumber: 1)
    }
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 2)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_EvmTransfer, rhs: Iotextypes_EvmTransfer) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_EvmTransferList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvmTransferList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "evmTransfers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.evmTransfers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.evmTransfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evmTransfers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_EvmTransferList, rhs: Iotextypes_EvmTransferList) -> Bool {
    if lhs.evmTransfers != rhs.evmTransfers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_ActionEvmTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionEvmTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionHash"),
    2: .same(proto: "numEvmTransfers"),
    3: .same(proto: "evmTransfers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.actionHash)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.numEvmTransfers)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.evmTransfers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.actionHash, fieldNumber: 1)
    }
    if self.numEvmTransfers != 0 {
      try visitor.visitSingularUInt64Field(value: self.numEvmTransfers, fieldNumber: 2)
    }
    if !self.evmTransfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evmTransfers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_ActionEvmTransfer, rhs: Iotextypes_ActionEvmTransfer) -> Bool {
    if lhs.actionHash != rhs.actionHash {return false}
    if lhs.numEvmTransfers != rhs.numEvmTransfers {return false}
    if lhs.evmTransfers != rhs.evmTransfers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_BlockEvmTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockEvmTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockHeight"),
    2: .same(proto: "numEvmTransfers"),
    3: .same(proto: "actionEvmTransfers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.blockHeight)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.numEvmTransfers)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.actionEvmTransfers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    if self.numEvmTransfers != 0 {
      try visitor.visitSingularUInt64Field(value: self.numEvmTransfers, fieldNumber: 2)
    }
    if !self.actionEvmTransfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionEvmTransfers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockEvmTransfer, rhs: Iotextypes_BlockEvmTransfer) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.numEvmTransfers != rhs.numEvmTransfers {return false}
    if lhs.actionEvmTransfers != rhs.actionEvmTransfers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_DepositToRewardingFund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepositToRewardingFund"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.amount)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_DepositToRewardingFund, rhs: Iotextypes_DepositToRewardingFund) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_ClaimFromRewardingFund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClaimFromRewardingFund"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.amount)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_ClaimFromRewardingFund, rhs: Iotextypes_ClaimFromRewardingFund) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_GrantReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrantReward"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .blockReward {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_GrantReward, rhs: Iotextypes_GrantReward) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
