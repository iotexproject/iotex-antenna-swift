// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/types/transaction_log.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2020 IoTeX
// This is an alpha (internal) release and is not suitable for production. This source code is provided 'as is' and no
// warranties are given as to title or non-infringement, merchantability or fitness for purpose and, to the extent
// permitted by law, all liability for your use of the code is disclaimed. This source code is governed by Apache
// License 2.0 that can be found in the LICENSE file.

/// To compile the proto, run:
///      protoc --go_out=plugins=grpc:$GOPATH/src *.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Iotextypes_TransactionLogType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case inContractTransfer // = 0
  case withdrawBucket // = 1
  case createBucket // = 2
  case depositToBucket // = 3
  case candidateSelfStake // = 4
  case candidateRegistrationFee // = 5
  case gasFee // = 6
  case nativeTransfer // = 7
  case depositToRewardingFund // = 8
  case claimFromRewardingFund // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .inContractTransfer
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inContractTransfer
    case 1: self = .withdrawBucket
    case 2: self = .createBucket
    case 3: self = .depositToBucket
    case 4: self = .candidateSelfStake
    case 5: self = .candidateRegistrationFee
    case 6: self = .gasFee
    case 7: self = .nativeTransfer
    case 8: self = .depositToRewardingFund
    case 9: self = .claimFromRewardingFund
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .inContractTransfer: return 0
    case .withdrawBucket: return 1
    case .createBucket: return 2
    case .depositToBucket: return 3
    case .candidateSelfStake: return 4
    case .candidateRegistrationFee: return 5
    case .gasFee: return 6
    case .nativeTransfer: return 7
    case .depositToRewardingFund: return 8
    case .claimFromRewardingFund: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Iotextypes_TransactionLogType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Iotextypes_TransactionLogType] = [
    .inContractTransfer,
    .withdrawBucket,
    .createBucket,
    .depositToBucket,
    .candidateSelfStake,
    .candidateRegistrationFee,
    .gasFee,
    .nativeTransfer,
    .depositToRewardingFund,
    .claimFromRewardingFund,
  ]
}

#endif  // swift(>=4.2)

public struct Iotextypes_TransactionLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionHash: Data = SwiftProtobuf.Internal.emptyData

  public var numTransactions: UInt64 = 0

  public var transactions: [Iotextypes_TransactionLog.Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Transaction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var topic: Data = SwiftProtobuf.Internal.emptyData

    public var amount: String = String()

    public var sender: String = String()

    public var recipient: String = String()

    public var type: Iotextypes_TransactionLogType = .inContractTransfer

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Iotextypes_TransactionLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var logs: [Iotextypes_TransactionLog] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iotextypes"

extension Iotextypes_TransactionLogType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IN_CONTRACT_TRANSFER"),
    1: .same(proto: "WITHDRAW_BUCKET"),
    2: .same(proto: "CREATE_BUCKET"),
    3: .same(proto: "DEPOSIT_TO_BUCKET"),
    4: .same(proto: "CANDIDATE_SELF_STAKE"),
    5: .same(proto: "CANDIDATE_REGISTRATION_FEE"),
    6: .same(proto: "GAS_FEE"),
    7: .same(proto: "NATIVE_TRANSFER"),
    8: .same(proto: "DEPOSIT_TO_REWARDING_FUND"),
    9: .same(proto: "CLAIM_FROM_REWARDING_FUND"),
  ]
}

extension Iotextypes_TransactionLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionLog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionHash"),
    2: .same(proto: "numTransactions"),
    3: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.actionHash)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.numTransactions)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.actionHash, fieldNumber: 1)
    }
    if self.numTransactions != 0 {
      try visitor.visitSingularUInt64Field(value: self.numTransactions, fieldNumber: 2)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_TransactionLog, rhs: Iotextypes_TransactionLog) -> Bool {
    if lhs.actionHash != rhs.actionHash {return false}
    if lhs.numTransactions != rhs.numTransactions {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_TransactionLog.Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Iotextypes_TransactionLog.protoMessageName + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "amount"),
    3: .same(proto: "sender"),
    4: .same(proto: "recipient"),
    5: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.topic)
      case 2: try decoder.decodeSingularStringField(value: &self.amount)
      case 3: try decoder.decodeSingularStringField(value: &self.sender)
      case 4: try decoder.decodeSingularStringField(value: &self.recipient)
      case 5: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularBytesField(value: self.topic, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 3)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 4)
    }
    if self.type != .inContractTransfer {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_TransactionLog.Transaction, rhs: Iotextypes_TransactionLog.Transaction) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_TransactionLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionLogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.logs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_TransactionLogs, rhs: Iotextypes_TransactionLogs) -> Bool {
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
