// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/types/blockchain.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018 IoTeX
// This is an alpha (internal) release and is not suitable for production. This source code is provided 'as is' and no
// warranties are given as to title or non-infringement, merchantability or fitness for purpose and, to the extent
// permitted by law, all liability for your use of the code is disclaimed. This source code is governed by Apache
// License 2.0 that can be found in the LICENSE file.

/// To compile the proto, run:
///      protoc --go_out=plugins=grpc:$GOPATH/src *.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// header of a block
public struct Iotextypes_BlockHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var core: Iotextypes_BlockHeaderCore {
    get {return _storage._core ?? Iotextypes_BlockHeaderCore()}
    set {_uniqueStorage()._core = newValue}
  }
  /// Returns true if `core` has been explicitly set.
  public var hasCore: Bool {return _storage._core != nil}
  /// Clears the value of `core`. Subsequent reads from it will return its default value.
  public mutating func clearCore() {_uniqueStorage()._core = nil}

  public var producerPubkey: Data {
    get {return _storage._producerPubkey}
    set {_uniqueStorage()._producerPubkey = newValue}
  }

  public var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Iotextypes_BlockHeaderCore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  public var prevBlockHash: Data {
    get {return _storage._prevBlockHash}
    set {_uniqueStorage()._prevBlockHash = newValue}
  }

  public var txRoot: Data {
    get {return _storage._txRoot}
    set {_uniqueStorage()._txRoot = newValue}
  }

  public var deltaStateDigest: Data {
    get {return _storage._deltaStateDigest}
    set {_uniqueStorage()._deltaStateDigest = newValue}
  }

  public var receiptRoot: Data {
    get {return _storage._receiptRoot}
    set {_uniqueStorage()._receiptRoot = newValue}
  }

  public var logsBloom: Data {
    get {return _storage._logsBloom}
    set {_uniqueStorage()._logsBloom = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// footer of a block
public struct Iotextypes_BlockFooter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var endorsements: [Iotextypes_Endorsement] {
    get {return _storage._endorsements}
    set {_uniqueStorage()._endorsements = newValue}
  }

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// body of a block
public struct Iotextypes_BlockBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actions: [Iotextypes_Action] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// block consists of header followed by transactions
/// hash of current block can be computed from header hence not stored
public struct Iotextypes_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Iotextypes_BlockHeader {
    get {return _storage._header ?? Iotextypes_BlockHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {_uniqueStorage()._header = nil}

  public var body: Iotextypes_BlockBody {
    get {return _storage._body ?? Iotextypes_BlockBody()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {_uniqueStorage()._body = nil}

  public var footer: Iotextypes_BlockFooter {
    get {return _storage._footer ?? Iotextypes_BlockFooter()}
    set {_uniqueStorage()._footer = newValue}
  }
  /// Returns true if `footer` has been explicitly set.
  public var hasFooter: Bool {return _storage._footer != nil}
  /// Clears the value of `footer`. Subsequent reads from it will return its default value.
  public mutating func clearFooter() {_uniqueStorage()._footer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Receipts consists of a collection of recepit
public struct Iotextypes_Receipts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var receipts: [Iotextypes_Receipt] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_EpochData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var num: UInt64 = 0

  public var height: UInt64 = 0

  public var gravityChainStartHeight: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Blockchain Metadata
public struct Iotextypes_ChainMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var numActions: Int64 {
    get {return _storage._numActions}
    set {_uniqueStorage()._numActions = newValue}
  }

  public var tps: Int64 {
    get {return _storage._tps}
    set {_uniqueStorage()._tps = newValue}
  }

  public var epoch: Iotextypes_EpochData {
    get {return _storage._epoch ?? Iotextypes_EpochData()}
    set {_uniqueStorage()._epoch = newValue}
  }
  /// Returns true if `epoch` has been explicitly set.
  public var hasEpoch: Bool {return _storage._epoch != nil}
  /// Clears the value of `epoch`. Subsequent reads from it will return its default value.
  public mutating func clearEpoch() {_uniqueStorage()._epoch = nil}

  public var tpsFloat: Float {
    get {return _storage._tpsFloat}
    set {_uniqueStorage()._tpsFloat = newValue}
  }

  public var chainID: UInt32 {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Block Metadata
public struct Iotextypes_BlockMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  public var numActions: Int64 {
    get {return _storage._numActions}
    set {_uniqueStorage()._numActions = newValue}
  }

  public var producerAddress: String {
    get {return _storage._producerAddress}
    set {_uniqueStorage()._producerAddress = newValue}
  }

  public var transferAmount: String {
    get {return _storage._transferAmount}
    set {_uniqueStorage()._transferAmount = newValue}
  }

  public var txRoot: String {
    get {return _storage._txRoot}
    set {_uniqueStorage()._txRoot = newValue}
  }

  public var receiptRoot: String {
    get {return _storage._receiptRoot}
    set {_uniqueStorage()._receiptRoot = newValue}
  }

  public var deltaStateDigest: String {
    get {return _storage._deltaStateDigest}
    set {_uniqueStorage()._deltaStateDigest = newValue}
  }

  public var logsBloom: String {
    get {return _storage._logsBloom}
    set {_uniqueStorage()._logsBloom = newValue}
  }

  public var previousBlockHash: String {
    get {return _storage._previousBlockHash}
    set {_uniqueStorage()._previousBlockHash = newValue}
  }

  public var gasLimit: UInt64 {
    get {return _storage._gasLimit}
    set {_uniqueStorage()._gasLimit = newValue}
  }

  public var gasUsed: UInt64 {
    get {return _storage._gasUsed}
    set {_uniqueStorage()._gasUsed = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BlockIdentifier Metadata
public struct Iotextypes_BlockIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Account Metadata
public struct Iotextypes_AccountMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var balance: String = String()

  public var nonce: UInt64 = 0

  public var pendingNonce: UInt64 = 0

  public var numActions: UInt64 = 0

  public var isContract: Bool = false

  public var contractByteCode: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Iotextypes_BlockStore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var block: Iotextypes_Block {
    get {return _storage._block ?? Iotextypes_Block()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {_uniqueStorage()._block = nil}

  public var receipts: [Iotextypes_Receipt] {
    get {return _storage._receipts}
    set {_uniqueStorage()._receipts = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Iotextypes_BlockStores {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockStores: [Iotextypes_BlockStore] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iotextypes"

extension Iotextypes_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "core"),
    2: .same(proto: "producerPubkey"),
    3: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _core: Iotextypes_BlockHeaderCore? = nil
    var _producerPubkey: Data = SwiftProtobuf.Internal.emptyData
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _core = source._core
      _producerPubkey = source._producerPubkey
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._core)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._producerPubkey)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._core {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._producerPubkey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._producerPubkey, fieldNumber: 2)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockHeader, rhs: Iotextypes_BlockHeader) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._core != rhs_storage._core {return false}
        if _storage._producerPubkey != rhs_storage._producerPubkey {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_BlockHeaderCore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockHeaderCore"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "height"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "prevBlockHash"),
    5: .same(proto: "txRoot"),
    6: .same(proto: "deltaStateDigest"),
    7: .same(proto: "receiptRoot"),
    8: .same(proto: "logsBloom"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt32 = 0
    var _height: UInt64 = 0
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _prevBlockHash: Data = SwiftProtobuf.Internal.emptyData
    var _txRoot: Data = SwiftProtobuf.Internal.emptyData
    var _deltaStateDigest: Data = SwiftProtobuf.Internal.emptyData
    var _receiptRoot: Data = SwiftProtobuf.Internal.emptyData
    var _logsBloom: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _height = source._height
      _timestamp = source._timestamp
      _prevBlockHash = source._prevBlockHash
      _txRoot = source._txRoot
      _deltaStateDigest = source._deltaStateDigest
      _receiptRoot = source._receiptRoot
      _logsBloom = source._logsBloom
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._version)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._prevBlockHash)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._txRoot)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._deltaStateDigest)
        case 7: try decoder.decodeSingularBytesField(value: &_storage._receiptRoot)
        case 8: try decoder.decodeSingularBytesField(value: &_storage._logsBloom)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 2)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._prevBlockHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._prevBlockHash, fieldNumber: 4)
      }
      if !_storage._txRoot.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._txRoot, fieldNumber: 5)
      }
      if !_storage._deltaStateDigest.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deltaStateDigest, fieldNumber: 6)
      }
      if !_storage._receiptRoot.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._receiptRoot, fieldNumber: 7)
      }
      if !_storage._logsBloom.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._logsBloom, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockHeaderCore, rhs: Iotextypes_BlockHeaderCore) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._prevBlockHash != rhs_storage._prevBlockHash {return false}
        if _storage._txRoot != rhs_storage._txRoot {return false}
        if _storage._deltaStateDigest != rhs_storage._deltaStateDigest {return false}
        if _storage._receiptRoot != rhs_storage._receiptRoot {return false}
        if _storage._logsBloom != rhs_storage._logsBloom {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_BlockFooter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockFooter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endorsements"),
    2: .same(proto: "timestamp"),
  ]

  fileprivate class _StorageClass {
    var _endorsements: [Iotextypes_Endorsement] = []
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _endorsements = source._endorsements
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._endorsements)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._endorsements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._endorsements, fieldNumber: 1)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockFooter, rhs: Iotextypes_BlockFooter) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._endorsements != rhs_storage._endorsements {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_BlockBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.actions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockBody, rhs: Iotextypes_BlockBody) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "body"),
    3: .same(proto: "footer"),
  ]

  fileprivate class _StorageClass {
    var _header: Iotextypes_BlockHeader? = nil
    var _body: Iotextypes_BlockBody? = nil
    var _footer: Iotextypes_BlockFooter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _body = source._body
      _footer = source._footer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._header)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._body)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._footer)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._footer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Block, rhs: Iotextypes_Block) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._footer != rhs_storage._footer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_Receipts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Receipts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receipts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.receipts)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.receipts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receipts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_Receipts, rhs: Iotextypes_Receipts) -> Bool {
    if lhs.receipts != rhs.receipts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_EpochData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EpochData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "height"),
    3: .same(proto: "gravityChainStartHeight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.num)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.height)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.gravityChainStartHeight)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.num != 0 {
      try visitor.visitSingularUInt64Field(value: self.num, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.gravityChainStartHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.gravityChainStartHeight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_EpochData, rhs: Iotextypes_EpochData) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs.height != rhs.height {return false}
    if lhs.gravityChainStartHeight != rhs.gravityChainStartHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_ChainMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "numActions"),
    3: .same(proto: "tps"),
    4: .same(proto: "epoch"),
    5: .same(proto: "tpsFloat"),
    6: .same(proto: "chainID"),
  ]

  fileprivate class _StorageClass {
    var _height: UInt64 = 0
    var _numActions: Int64 = 0
    var _tps: Int64 = 0
    var _epoch: Iotextypes_EpochData? = nil
    var _tpsFloat: Float = 0
    var _chainID: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _numActions = source._numActions
      _tps = source._tps
      _epoch = source._epoch
      _tpsFloat = source._tpsFloat
      _chainID = source._chainID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._numActions)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._tps)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._epoch)
        case 5: try decoder.decodeSingularFloatField(value: &_storage._tpsFloat)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._chainID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 1)
      }
      if _storage._numActions != 0 {
        try visitor.visitSingularInt64Field(value: _storage._numActions, fieldNumber: 2)
      }
      if _storage._tps != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tps, fieldNumber: 3)
      }
      if let v = _storage._epoch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._tpsFloat != 0 {
        try visitor.visitSingularFloatField(value: _storage._tpsFloat, fieldNumber: 5)
      }
      if _storage._chainID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._chainID, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_ChainMeta, rhs: Iotextypes_ChainMeta) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._numActions != rhs_storage._numActions {return false}
        if _storage._tps != rhs_storage._tps {return false}
        if _storage._epoch != rhs_storage._epoch {return false}
        if _storage._tpsFloat != rhs_storage._tpsFloat {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_BlockMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "numActions"),
    5: .same(proto: "producerAddress"),
    6: .same(proto: "transferAmount"),
    7: .same(proto: "txRoot"),
    8: .same(proto: "receiptRoot"),
    9: .same(proto: "deltaStateDigest"),
    10: .same(proto: "logsBloom"),
    11: .same(proto: "previousBlockHash"),
    12: .same(proto: "gasLimit"),
    13: .same(proto: "gasUsed"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _height: UInt64 = 0
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _numActions: Int64 = 0
    var _producerAddress: String = String()
    var _transferAmount: String = String()
    var _txRoot: String = String()
    var _receiptRoot: String = String()
    var _deltaStateDigest: String = String()
    var _logsBloom: String = String()
    var _previousBlockHash: String = String()
    var _gasLimit: UInt64 = 0
    var _gasUsed: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _height = source._height
      _timestamp = source._timestamp
      _numActions = source._numActions
      _producerAddress = source._producerAddress
      _transferAmount = source._transferAmount
      _txRoot = source._txRoot
      _receiptRoot = source._receiptRoot
      _deltaStateDigest = source._deltaStateDigest
      _logsBloom = source._logsBloom
      _previousBlockHash = source._previousBlockHash
      _gasLimit = source._gasLimit
      _gasUsed = source._gasUsed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._hash)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._numActions)
        case 5: try decoder.decodeSingularStringField(value: &_storage._producerAddress)
        case 6: try decoder.decodeSingularStringField(value: &_storage._transferAmount)
        case 7: try decoder.decodeSingularStringField(value: &_storage._txRoot)
        case 8: try decoder.decodeSingularStringField(value: &_storage._receiptRoot)
        case 9: try decoder.decodeSingularStringField(value: &_storage._deltaStateDigest)
        case 10: try decoder.decodeSingularStringField(value: &_storage._logsBloom)
        case 11: try decoder.decodeSingularStringField(value: &_storage._previousBlockHash)
        case 12: try decoder.decodeSingularUInt64Field(value: &_storage._gasLimit)
        case 13: try decoder.decodeSingularUInt64Field(value: &_storage._gasUsed)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 2)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._numActions != 0 {
        try visitor.visitSingularInt64Field(value: _storage._numActions, fieldNumber: 4)
      }
      if !_storage._producerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._producerAddress, fieldNumber: 5)
      }
      if !_storage._transferAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transferAmount, fieldNumber: 6)
      }
      if !_storage._txRoot.isEmpty {
        try visitor.visitSingularStringField(value: _storage._txRoot, fieldNumber: 7)
      }
      if !_storage._receiptRoot.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiptRoot, fieldNumber: 8)
      }
      if !_storage._deltaStateDigest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deltaStateDigest, fieldNumber: 9)
      }
      if !_storage._logsBloom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logsBloom, fieldNumber: 10)
      }
      if !_storage._previousBlockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._previousBlockHash, fieldNumber: 11)
      }
      if _storage._gasLimit != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gasLimit, fieldNumber: 12)
      }
      if _storage._gasUsed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gasUsed, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockMeta, rhs: Iotextypes_BlockMeta) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._numActions != rhs_storage._numActions {return false}
        if _storage._producerAddress != rhs_storage._producerAddress {return false}
        if _storage._transferAmount != rhs_storage._transferAmount {return false}
        if _storage._txRoot != rhs_storage._txRoot {return false}
        if _storage._receiptRoot != rhs_storage._receiptRoot {return false}
        if _storage._deltaStateDigest != rhs_storage._deltaStateDigest {return false}
        if _storage._logsBloom != rhs_storage._logsBloom {return false}
        if _storage._previousBlockHash != rhs_storage._previousBlockHash {return false}
        if _storage._gasLimit != rhs_storage._gasLimit {return false}
        if _storage._gasUsed != rhs_storage._gasUsed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_BlockIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hash)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockIdentifier, rhs: Iotextypes_BlockIdentifier) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_AccountMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
    3: .same(proto: "nonce"),
    4: .same(proto: "pendingNonce"),
    5: .same(proto: "numActions"),
    6: .same(proto: "isContract"),
    7: .same(proto: "contractByteCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularStringField(value: &self.balance)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.nonce)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.pendingNonce)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.numActions)
      case 6: try decoder.decodeSingularBoolField(value: &self.isContract)
      case 7: try decoder.decodeSingularBytesField(value: &self.contractByteCode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.balance.isEmpty {
      try visitor.visitSingularStringField(value: self.balance, fieldNumber: 2)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 3)
    }
    if self.pendingNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.pendingNonce, fieldNumber: 4)
    }
    if self.numActions != 0 {
      try visitor.visitSingularUInt64Field(value: self.numActions, fieldNumber: 5)
    }
    if self.isContract != false {
      try visitor.visitSingularBoolField(value: self.isContract, fieldNumber: 6)
    }
    if !self.contractByteCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractByteCode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_AccountMeta, rhs: Iotextypes_AccountMeta) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.pendingNonce != rhs.pendingNonce {return false}
    if lhs.numActions != rhs.numActions {return false}
    if lhs.isContract != rhs.isContract {return false}
    if lhs.contractByteCode != rhs.contractByteCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_BlockStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockStore"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "receipts"),
  ]

  fileprivate class _StorageClass {
    var _block: Iotextypes_Block? = nil
    var _receipts: [Iotextypes_Receipt] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _block = source._block
      _receipts = source._receipts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._block)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._receipts)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._receipts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._receipts, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockStore, rhs: Iotextypes_BlockStore) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._block != rhs_storage._block {return false}
        if _storage._receipts != rhs_storage._receipts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_BlockStores: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockStores"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockStores"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.blockStores)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockStores.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockStores, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Iotextypes_BlockStores, rhs: Iotextypes_BlockStores) -> Bool {
    if lhs.blockStores != rhs.blockStores {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
