// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/types/consensus.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2019 IoTeX
// This is an alpha (internal) release and is not suitable for production. This source code is provided 'as is' and no
// warranties are given as to title or non-infringement, merchantability or fitness for purpose and, to the extent
// permitted by law, all liability for your use of the code is disclaimed. This source code is governed by Apache
// License 2.0 that can be found in the LICENSE file.

/// To compile the proto, run:
///      protoc --go_out=plugins=grpc:$GOPATH/src *.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Iotextypes_BlockProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Iotextypes_Block {
    get {return _storage._block ?? Iotextypes_Block()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {_uniqueStorage()._block = nil}

  var endorsements: [Iotextypes_Endorsement] {
    get {return _storage._endorsements}
    set {_uniqueStorage()._endorsements = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iotextypes_ConsensusVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHash: Data = SwiftProtobuf.Internal.emptyData

  var topic: Iotextypes_ConsensusVote.Topic = .proposal

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Topic: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case proposal // = 0
    case lock // = 1
    case commit // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .proposal
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .proposal
      case 1: self = .lock
      case 2: self = .commit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .proposal: return 0
      case .lock: return 1
      case .commit: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Iotextypes_ConsensusVote.Topic: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Iotextypes_ConsensusVote.Topic] = [
    .proposal,
    .lock,
    .commit,
  ]
}

#endif  // swift(>=4.2)

struct Iotextypes_ConsensusMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  var endorsement: Iotextypes_Endorsement {
    get {return _storage._endorsement ?? Iotextypes_Endorsement()}
    set {_uniqueStorage()._endorsement = newValue}
  }
  /// Returns true if `endorsement` has been explicitly set.
  var hasEndorsement: Bool {return _storage._endorsement != nil}
  /// Clears the value of `endorsement`. Subsequent reads from it will return its default value.
  mutating func clearEndorsement() {_uniqueStorage()._endorsement = nil}

  var msg: OneOf_Msg? {
    get {return _storage._msg}
    set {_uniqueStorage()._msg = newValue}
  }

  var blockProposal: Iotextypes_BlockProposal {
    get {
      if case .blockProposal(let v)? = _storage._msg {return v}
      return Iotextypes_BlockProposal()
    }
    set {_uniqueStorage()._msg = .blockProposal(newValue)}
  }

  var vote: Iotextypes_ConsensusVote {
    get {
      if case .vote(let v)? = _storage._msg {return v}
      return Iotextypes_ConsensusVote()
    }
    set {_uniqueStorage()._msg = .vote(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable {
    case blockProposal(Iotextypes_BlockProposal)
    case vote(Iotextypes_ConsensusVote)

  #if !swift(>=4.1)
    static func ==(lhs: Iotextypes_ConsensusMessage.OneOf_Msg, rhs: Iotextypes_ConsensusMessage.OneOf_Msg) -> Bool {
      switch (lhs, rhs) {
      case (.blockProposal(let l), .blockProposal(let r)): return l == r
      case (.vote(let l), .vote(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iotextypes"

extension Iotextypes_BlockProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "endorsements"),
  ]

  fileprivate class _StorageClass {
    var _block: Iotextypes_Block? = nil
    var _endorsements: [Iotextypes_Endorsement] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _block = source._block
      _endorsements = source._endorsements
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._block)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._endorsements)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._endorsements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._endorsements, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotextypes_BlockProposal, rhs: Iotextypes_BlockProposal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._block != rhs_storage._block {return false}
        if _storage._endorsements != rhs_storage._endorsements {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_ConsensusVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsensusVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockHash"),
    2: .same(proto: "topic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.blockHash)
      case 2: try decoder.decodeSingularEnumField(value: &self.topic)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 1)
    }
    if self.topic != .proposal {
      try visitor.visitSingularEnumField(value: self.topic, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotextypes_ConsensusVote, rhs: Iotextypes_ConsensusVote) -> Bool {
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iotextypes_ConsensusVote.Topic: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPOSAL"),
    1: .same(proto: "LOCK"),
    2: .same(proto: "COMMIT"),
  ]
}

extension Iotextypes_ConsensusMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsensusMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "endorsement"),
    100: .same(proto: "blockProposal"),
    101: .same(proto: "vote"),
  ]

  fileprivate class _StorageClass {
    var _height: UInt64 = 0
    var _endorsement: Iotextypes_Endorsement? = nil
    var _msg: Iotextypes_ConsensusMessage.OneOf_Msg?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _endorsement = source._endorsement
      _msg = source._msg
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._endorsement)
        case 100:
          var v: Iotextypes_BlockProposal?
          if let current = _storage._msg {
            try decoder.handleConflictingOneOf()
            if case .blockProposal(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._msg = .blockProposal(v)}
        case 101:
          var v: Iotextypes_ConsensusVote?
          if let current = _storage._msg {
            try decoder.handleConflictingOneOf()
            if case .vote(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._msg = .vote(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 1)
      }
      if let v = _storage._endorsement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      switch _storage._msg {
      case .blockProposal(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .vote(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iotextypes_ConsensusMessage, rhs: Iotextypes_ConsensusMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._endorsement != rhs_storage._endorsement {return false}
        if _storage._msg != rhs_storage._msg {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
